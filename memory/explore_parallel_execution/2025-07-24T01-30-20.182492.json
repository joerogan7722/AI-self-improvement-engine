{
  "cycle": null,
  "goal_id": "explore_parallel_execution",
  "description": "Investigate the possibility of executing independent goals in parallel to improve performance.",
  "current_code": "# File: src/ai_self_ext_engine/goal_manager.py\nimport json\nfrom pathlib import Path\nimport logging # Import logging\nfrom typing import Any, Dict, List, Optional\n\nclass Goal:\n    \"\"\"Represents a single improvement goal.\"\"\"\n    def __init__(self, goal_id: str, description: str, status: str = \"pending\", \n                 priority: str = \"medium\", metadata: Optional[Dict[str, Any]] = None):\n        self.goal_id = goal_id\n        self.description = description\n        self.status = status\n        self.priority = priority\n        self.metadata = metadata or {}\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.goal_id, \n            \"description\": self.description, \n            \"status\": self.status,\n            \"priority\": self.priority,\n            \"metadata\": self.metadata\n        }\n\nclass GoalManager:\n    \"\"\"Manages the loading, serving, and tracking of improvement goals.\"\"\"\n    def __init__(self, goals_path: str):\n        # Ensure the parent directory for the goals file exists\n        Path(goals_path).parent.mkdir(parents=True, exist_ok=True)\n        self.goals_path = Path(goals_path)\n        self.logger = logging.getLogger(__name__) # New logger\n        self.goals: List[Goal] = []\n        self._load_goals()\n        self._current_goal_index = 0\n\n    def _load_goals(self):\n        \"\"\"Loads goals from the specified JSON file.\"\"\"\n        if not self.goals_path.exists():\n            self.logger.info(f\"Goals file not found at {self.goals_path}. Starting with no goals.\")\n            return\n\n        try:\n            with open(self.goals_path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                # If data is a list, assume it's directly the list of goal items\n                if isinstance(data, list):\n                    goal_items = data\n                else: # Otherwise, assume it's a dict with a \"goals\" key\n                    goal_items = data.get(\"goals\", [])\n\n                for item in goal_items:\n                    # Map 'id' from JSON to 'goal_id' for Goal constructor\n                    goal_id = item.pop('id') if 'id' in item else item.get('goal_id', '')\n                    description = item.get('description', '')\n                    status = item.get('status', 'pending')\n                    priority = item.get('priority', 'medium')\n                    metadata = item.get('metadata', {})\n                    \n                    self.goals.append(Goal(\n                        goal_id=goal_id,\n                        description=description,\n                        status=status,\n                        priority=priority,\n                        metadata=metadata\n                    ))\n        except json.JSONDecodeError:\n            self.logger.error(f\"Error decoding goals JSON from {self.goals_path}. File might be corrupted.\")\n        except Exception as e:\n            self.logger.error(f\"Error loading goals from {self.goals_path}: {e}\")\n\n    def save_goals(self):\n        \"\"\"Saves the current state of goals back to the JSON file.\"\"\"\n        # Always save as a dictionary with a \"goals\" key\n        data = {\"goals\": [goal.to_dict() for goal in self.goals]}\n        try:\n            with open(self.goals_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2)\n        except Exception as e: # Catch any file-related errors\n            self.logger.error(f\"Error saving goals to {self.goals_path}: {e}\")\n\n    def next_goal(self) -> Optional[Goal]:\n        \"\"\"Returns the next pending goal, or None if no more pending goals.\"\"\"\n        # Find the next pending goal starting from the current index\n        for i in range(self._current_goal_index, len(self.goals)):\n            goal = self.goals[i]\n            if goal.status == \"pending\":\n                self._current_goal_index = i + 1  # Advance the index for the next call\n                return goal\n        self._current_goal_index = len(self.goals) # Set index to end if no more pending goals\n        return None\n\n    def mark_done(self, goal_id: str):\n        \"\"\"Marks a goal as completed.\"\"\"\n        for goal in self.goals:\n            if goal.goal_id == goal_id:\n                goal.status = \"completed\"\n                self.save_goals()\n                self.logger.info(f\"Goal '{goal_id}' marked as completed.\")\n                return\n        self.logger.warning(f\"Goal '{goal_id}' not found when trying to mark as done.\")\n\n    def add_goal(self, goal: Goal):\n        \"\"\"Adds a new goal to the manager.\"\"\"\n        self.goals.append(goal)\n        self.save_goals()\n        self.logger.info(f\"Added new goal: {goal.goal_id}\")\n\n    def add_goal_from_dict(self, goal_data: Dict[str, Any]):\n        \"\"\"Adds a new goal from a dictionary.\"\"\"\n        self.goals.append(Goal(goal_data[\"id\"], goal_data[\"description\"], goal_data.get(\"status\", \"pending\")))\n        self.save_goals()\n        self.logger.info(f\"Added new goal: {goal_data['id']}\")\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/goal_manager.py",
      "change_type": "modify",
      "description": "Refactor GoalManager to support tracking and managing multiple active goals concurrently, preparing for parallel execution."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/goal_manager.py\n+++ b/src/ai_self_ext_engine/goal_manager.py\n@@ -1,7 +1,7 @@\n import json\n from pathlib import Path\n import logging # Import logging\n-from typing import Any, Dict, List, Optional\n+from typing import Any, Dict, List, Optional, Set # Import Set\n \n class Goal:\n     \"\"\"Represents a single improvement goal.\"\"\"\n     def __init__(self, goal_id: str, description: str, status: str = \"pending\", \n                  priority: str = \"medium\", metadata: Optional[Dict[str, Any]] = None):\n         self.goal_id = goal_id\n         self.description = description\n         self.status = status\n         self.priority = priority\n         self.metadata = metadata or {}\n \n     def to_dict(self) -> Dict[str, Any]:\n         return {\n             \"id\": self.goal_id, \n             \"description\": self.description, \n             \"status\": self.status,\n             \"priority\": self.priority,\n             \"metadata\": self.metadata\n         }\n \n class GoalManager:\n     \"\"\"Manages the loading, serving, and tracking of improvement goals.\"\"\"\n     def __init__(self, goals_path: str):\n         # Ensure the parent directory for the goals file exists\n         Path(goals_path).parent.mkdir(parents=True, exist_ok=True)\n         self.goals_path = Path(goals_path)\n         self.logger = logging.getLogger(__name__) # New logger\n         self.goals: List[Goal] = []\n+        self.active_goal_ids: Set[str] = set() # Track IDs of goals currently being processed\n         self._load_goals()\n-        self._current_goal_index = 0\n \n     def _load_goals(self):\n         \"\"\"Loads goals from the specified JSON file.\"\"\"\n@@ -24,6 +24,10 @@\n                     status = item.get('status', 'pending')\n                     priority = item.get('priority', 'medium')\n                     metadata = item.get('metadata', {})\n+\n+                    # On load, reset any 'active' goals to 'pending' to ensure a clean state\n+                    if status == \"active\":\n+                        self.logger.warning(f\"Goal '{goal_id}' was active on load. Resetting to 'pending'.\")\n+                        status = \"pending\"\n                     \n                     self.goals.append(Goal(\n                         goal_id=goal_id,\n@@ -32,6 +36,10 @@\n                         priority=priority,\n                         metadata=metadata\n                     ))\n+            \n+            # After loading, rebuild active_goal_ids (should be empty if all 'active' were reset)\n+            self.active_goal_ids = {g.goal_id for g in self.goals if g.status == \"active\"}\n+            self.logger.info(f\"Loaded {len(self.goals)} goals from {self.goals_path}.\")\n         except json.JSONDecodeError:\n             self.logger.error(f\"Error decoding goals JSON from {self.goals_path}. File might be corrupted.\")\n         except Exception as e:\n             self.logger.error(f\"Error loading goals from {self.goals_path}: {e}\")\n \n     def save_goals(self):\n         \"\"\"Saves the current state of goals back to the JSON file.\"\"\"\n         # Always save as a dictionary with a \"goals\" key\n         data = {\"goals\": [goal.to_dict() for goal in self.goals]}\n         try:\n             with open(self.goals_path, 'w', encoding='utf-8') as f:\n                 json.dump(data, f, indent=2)\n+            self.logger.debug(f\"Goals saved to {self.goals_path}.\")\n         except Exception as e: # Catch any file-related errors\n             self.logger.error(f\"Error saving goals to {self.goals_path}: {e}\")\n \n-    def next_goal(self) -> Optional[Goal]:\n-        \"\"\"Returns the next pending goal, or None if no more pending goals.\"\"\"\n-        # Find the next pending goal starting from the current index\n-        for i in range(self._current_goal_index, len(self.goals)):\n-            goal = self.goals[i]\n-            if goal.status == \"pending\":\n-                self._current_goal_index = i + 1  # Advance the index for the next call\n-                return goal\n-        self._current_goal_index = len(self.goals) # Set index to end if no more pending goals\n+    def get_active_goals(self) -> List[Goal]:\n+        \"\"\"Returns a list of all goals currently marked as 'active'.\"\"\"\n+        return [goal for goal in self.goals if goal.status == \"active\"]\n+\n+    def request_goal_for_activation(self) -> Optional[Goal]:\n+        \"\"\"\n+        Finds the highest priority pending goal not already active, marks it as 'active',\n+        adds it to the active set, saves, and returns it.\n+        Returns None if no pending goals are available.\n+        \"\"\"\n+        # Prioritize 'high', then 'medium', then 'low'\n+        priorities = [\"high\", \"medium\", \"low\"]\n+        \n+        for priority in priorities:\n+            for goal in self.goals:\n+                if goal.status == \"pending\" and goal.priority == priority and goal.goal_id not in self.active_goal_ids:\n+                    goal.status = \"active\"\n+                    self.active_goal_ids.add(goal.goal_id)\n+                    self.save_goals()\n+                    self.logger.info(f\"Goal '{goal.goal_id}' activated for processing (priority: {priority}).\")\n+                    return goal\n+        \n+        self.logger.info(\"No pending goals available for activation.\")\n         return None\n \n     def mark_done(self, goal_id: str):\n         \"\"\"Marks a goal as completed.\"\"\"\n         for goal in self.goals:\n             if goal.goal_id == goal_id:\n                 goal.status = \"completed\"\n+                if goal_id in self.active_goal_ids:\n+                    self.active_goal_ids.remove(goal_id)\n                 self.save_goals()\n                 self.logger.info(f\"Goal '{goal_id}' marked as completed.\")\n                 return\n         self.logger.warning(f\"Goal '{goal_id}' not found when trying to mark as done.\")\n \n     def add_goal(self, goal: Goal):\n         \"\"\"Adds a new goal to the manager.\"\"\"\n+        # Ensure the goal is not added as 'active' initially; it must be requested for activation.\n+        if goal.status == \"active\":\n+            goal.status = \"pending\"\n+            self.logger.warning(f\"Attempted to add goal '{goal.goal_id}' as 'active'. Resetting to 'pending'. Goals must be activated via request_goal_for_activation().\")\n         self.goals.append(goal)\n         self.save_goals()\n         self.logger.info(f\"Added new goal: {goal.goal_id}\")\n \n     def add_goal_from_dict(self, goal_data: Dict[str, Any]):\n         \"\"\"Adds a new goal from a dictionary.\"\"\"\n-        self.goals.append(Goal(goal_data[\"id\"], goal_data[\"description\"], goal_data.get(\"status\", \"pending\")))\n+        # Ensure the goal is not added as 'active' initially; it must be requested for activation.\n+        status = goal_data.get(\"status\", \"pending\")\n+        if status == \"active\":\n+            status = \"pending\"\n+            self.logger.warning(f\"Attempted to add goal '{goal_data.get('id', 'unknown')}' as 'active'. Resetting to 'pending'. Goals must be activated via request_goal_for_activation().\")\n+\n+        self.goals.append(Goal(goal_data[\"id\"], goal_data[\"description\"], status=status,\n+                               priority=goal_data.get(\"priority\", \"medium\"), # Ensure priority is passed\n+                               metadata=goal_data.get(\"metadata\", {}))) # Ensure metadata is passed\n         self.save_goals()\n         self.logger.info(f\"Added new goal: {goal_data['id']}\")\n+\n+    def mark_failed(self, goal_id: str, reason: Optional[str] = None):\n+        \"\"\"Marks a goal as failed.\"\"\"\n+        for goal in self.goals:\n+            if goal.goal_id == goal_id:\n+                goal.status = \"failed\"\n+                if goal_id in self.active_goal_ids:\n+                    self.active_goal_ids.remove(goal_id)\n+                self.save_goals()\n+                self.logger.warning(f\"Goal '{goal_id}' marked as failed. Reason: {reason or 'Not specified'}\")\n+                return\n+        self.logger.warning(f\"Goal '{goal_id}' not found when trying to mark as failed.\")\n+\n+    def release_goal(self, goal_id: str, new_status: str = \"pending\"):\n+        \"\"\"\n+        Releases an active goal, changing its status to the specified new_status (defaulting to 'pending').\n+        Useful for pausing or deferring goals.\n+        \"\"\"\n+        if new_status not in [\"pending\", \"paused\", \"failed\", \"completed\"]: # Define allowed states for release\n+            self.logger.error(f\"Invalid status '{new_status}' for releasing goal '{goal_id}'. Must be 'pending', 'paused', 'failed', or 'completed'.\")\n+            return\n+\n+        for goal in self.goals:\n+            if goal.goal_id == goal_id:\n+                # Check if it's currently active or still in the active_goal_ids set\n+                if goal.status == \"active\" or goal_id in self.active_goal_ids:\n+                    goal.status = new_status\n+                    if goal_id in self.active_goal_ids:\n+                        self.active_goal_ids.remove(goal_id)\n+                    self.save_goals()\n+                    self.logger.info(f\"Goal '{goal_id}' released and status changed to '{new_status}'.\")\n+                else:\n+                    self.logger.warning(f\"Goal '{goal_id}' is not active or already released. Current status is '{goal.status}'.\")\n+                return\n+        self.logger.warning(f\"Goal '{goal_id}' not found when trying to release.\")",
  "test_results": {
    "passed": false,
    "error": "pytest not found"
  },
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}