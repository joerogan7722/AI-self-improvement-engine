{
  "cycle": null,
  "goal_id": "explore_parallel_execution",
  "description": "Investigate the possibility of executing independent goals in parallel to improve performance.",
  "current_code": "# File: src/ai_self_ext_engine/goal_manager.py\nimport json\nfrom pathlib import Path\nimport logging # Import logging\nfrom typing import Any, Dict, List, Optional\n\nclass Goal:\n    \"\"\"Represents a single improvement goal.\"\"\"\n    def __init__(self, goal_id: str, description: str, status: str = \"pending\", \n                 priority: str = \"medium\", metadata: Optional[Dict[str, Any]] = None):\n        self.goal_id = goal_id\n        self.description = description\n        self.status = status\n        self.priority = priority\n        self.metadata = metadata or {}\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.goal_id, \n            \"description\": self.description, \n            \"status\": self.status,\n            \"priority\": self.priority,\n            \"metadata\": self.metadata\n        }\n\nclass GoalManager:\n    \"\"\"Manages the loading, serving, and tracking of improvement goals.\"\"\"\n    def __init__(self, goals_path: str):\n        # Ensure the parent directory for the goals file exists\n        Path(goals_path).parent.mkdir(parents=True, exist_ok=True)\n        self.goals_path = Path(goals_path)\n        self.logger = logging.getLogger(__name__) # New logger\n        self.goals: List[Goal] = []\n        self._load_goals()\n        self._current_goal_index = 0\n\n    def _load_goals(self):\n        \"\"\"Loads goals from the specified JSON file.\"\"\"\n        if not self.goals_path.exists():\n            self.logger.info(f\"Goals file not found at {self.goals_path}. Starting with no goals.\")\n            return\n\n        try:\n            with open(self.goals_path, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                # If data is a list, assume it's directly the list of goal items\n                if isinstance(data, list):\n                    goal_items = data\n                else: # Otherwise, assume it's a dict with a \"goals\" key\n                    goal_items = data.get(\"goals\", [])\n\n                for item in goal_items:\n                    # Map 'id' from JSON to 'goal_id' for Goal constructor\n                    goal_id = item.pop('id') if 'id' in item else item.get('goal_id', '')\n                    description = item.get('description', '')\n                    status = item.get('status', 'pending')\n                    priority = item.get('priority', 'medium')\n                    metadata = item.get('metadata', {})\n                    \n                    self.goals.append(Goal(\n                        goal_id=goal_id,\n                        description=description,\n                        status=status,\n                        priority=priority,\n                        metadata=metadata\n                    ))\n        except json.JSONDecodeError:\n            self.logger.error(f\"Error decoding goals JSON from {self.goals_path}. File might be corrupted.\")\n        except Exception as e:\n            self.logger.error(f\"Error loading goals from {self.goals_path}: {e}\")\n\n    def save_goals(self):\n        \"\"\"Saves the current state of goals back to the JSON file.\"\"\"\n        # Always save as a dictionary with a \"goals\" key\n        data = {\"goals\": [goal.to_dict() for goal in self.goals]}\n        try:\n            with open(self.goals_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2)\n        except Exception as e: # Catch any file-related errors\n            self.logger.error(f\"Error saving goals to {self.goals_path}: {e}\")\n\n    def next_goal(self) -> Optional[Goal]:\n        \"\"\"Returns the next pending goal, or None if no more pending goals.\"\"\"\n        # Find the next pending goal starting from the current index\n        for i in range(self._current_goal_index, len(self.goals)):\n            goal = self.goals[i]\n            if goal.status == \"pending\":\n                self._current_goal_index = i + 1  # Advance the index for the next call\n                return goal\n        self._current_goal_index = len(self.goals) # Set index to end if no more pending goals\n        return None\n\n    def mark_done(self, goal_id: str):\n        \"\"\"Marks a goal as completed.\"\"\"\n        for goal in self.goals:\n            if goal.goal_id == goal_id:\n                goal.status = \"completed\"\n                self.save_goals()\n                self.logger.info(f\"Goal '{goal_id}' marked as completed.\")\n                return\n        self.logger.warning(f\"Goal '{goal_id}' not found when trying to mark as done.\")\n\n    def add_goal(self, goal: Goal):\n        \"\"\"Adds a new goal to the manager.\"\"\"\n        self.goals.append(goal)\n        self.save_goals()\n        self.logger.info(f\"Added new goal: {goal.goal_id}\")\n\n    def add_goal_from_dict(self, goal_data: Dict[str, Any]):\n        \"\"\"Adds a new goal from a dictionary.\"\"\"\n        self.goals.append(Goal(goal_data[\"id\"], goal_data[\"description\"], goal_data.get(\"status\", \"pending\")))\n        self.save_goals()\n        self.logger.info(f\"Added new goal: {goal_data['id']}\")\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/goal_manager.py",
      "change_type": "modify",
      "description": "Refactor `GoalManager` to support asynchronous goal processing, enabling non-blocking execution and preparing for parallel independent goal handling."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/goal_manager.py\n+++ b/src/ai_self_ext_engine/goal_manager.py\n@@ -1,6 +1,7 @@\n import json\n from pathlib import Path\n import logging # Import logging\n+import aiofiles # Import aiofiles for async file operations\n from typing import Any, Dict, List, Optional\n \n class Goal:\n@@ -30,22 +31,23 @@\n         self.goals: List[Goal] = []\n         self._load_goals()\n         self._current_goal_index = 0\n+        self.logger.info(f\"GoalManager initialized for path: {self.goals_path}\")\n \n-    def _load_goals(self):\n+    async def _load_goals(self):\n         \"\"\"Loads goals from the specified JSON file.\"\"\"\n         if not self.goals_path.exists():\n             self.logger.info(f\"Goals file not found at {self.goals_path}. Starting with no goals.\")\n             return\n \n         try:\n-            with open(self.goals_path, 'r', encoding='utf-8') as f:\n-                data = json.load(f)\n+            async with aiofiles.open(self.goals_path, mode='r', encoding='utf-8') as f:\n+                content = await f.read()\n+                data = json.loads(content)\n                 # If data is a list, assume it's directly the list of goal items\n                 if isinstance(data, list):\n                     goal_items = data\n                 else: # Otherwise, assume it's a dict with a \"goals\" key\n                     goal_items = data.get(\"goals\", [])\n-\n                 for item in goal_items:\n                     # Map 'id' from JSON to 'goal_id' for Goal constructor\n                     goal_id = item.pop('id') if 'id' in item else item.get('goal_id', '')\n@@ -62,21 +64,21 @@\n         except Exception as e:\n             self.logger.error(f\"Error loading goals from {self.goals_path}: {e}\")\n \n-    def save_goals(self):\n+    async def save_goals(self):\n         \"\"\"Saves the current state of goals back to the JSON file.\"\"\"\n         # Always save as a dictionary with a \"goals\" key\n         data = {\"goals\": [goal.to_dict() for goal in self.goals]}\n         try:\n-            with open(self.goals_path, 'w', encoding='utf-8') as f:\n-                json.dump(data, f, indent=2)\n+            async with aiofiles.open(self.goals_path, mode='w', encoding='utf-8') as f:\n+                await f.write(json.dumps(data, indent=2))\n         except Exception as e: # Catch any file-related errors\n             self.logger.error(f\"Error saving goals to {self.goals_path}: {e}\")\n \n-    def next_goal(self) -> Optional[Goal]:\n+    async def next_goal(self) -> Optional[Goal]:\n         \"\"\"Returns the next pending goal, or None if no more pending goals.\"\"\"\n         # Find the next pending goal starting from the current index\n         for i in range(self._current_goal_index, len(self.goals)):\n             goal = self.goals[i]\n             if goal.status == \"pending\":\n                 self._current_goal_index = i + 1  # Advance the index for the next call\n                 return goal\n@@ -84,23 +86,23 @@\n         self._current_goal_index = len(self.goals) # Set index to end if no more pending goals\n         return None\n \n-    def mark_done(self, goal_id: str):\n+    async def mark_done(self, goal_id: str):\n         \"\"\"Marks a goal as completed.\"\"\"\n         for goal in self.goals:\n             if goal.goal_id == goal_id:\n                 goal.status = \"completed\"\n-                self.save_goals()\n+                await self.save_goals()\n                 self.logger.info(f\"Goal '{goal_id}' marked as completed.\")\n                 return\n         self.logger.warning(f\"Goal '{goal_id}' not found when trying to mark as done.\")\n \n-    def add_goal(self, goal: Goal):\n+    async def add_goal(self, goal: Goal):\n         \"\"\"Adds a new goal to the manager.\"\"\"\n         self.goals.append(goal)\n-        self.save_goals()\n+        await self.save_goals()\n         self.logger.info(f\"Added new goal: {goal.goal_id}\")\n \n-    def add_goal_from_dict(self, goal_data: Dict[str, Any]):\n+    async def add_goal_from_dict(self, goal_data: Dict[str, Any]):\n         \"\"\"Adds a new goal from a dictionary.\"\"\"\n         self.goals.append(Goal(goal_data[\"id\"], goal_data[\"description\"], goal_data.get(\"status\", \"pending\")))\n-        self.save_goals()\n+        await self.save_goals()\n         self.logger.info(f\"Added new goal: {goal_data['id']}\")",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}