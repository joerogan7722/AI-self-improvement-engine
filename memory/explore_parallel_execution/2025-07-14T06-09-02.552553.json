{
  "cycle": null,
  "goal_id": "explore_parallel_execution",
  "description": "Investigate the possibility of executing independent goals in parallel to improve performance.",
  "current_code": "# File: src/ai_self_ext_engine/core/engine.py\nfrom typing import List, Dict, cast\nfrom importlib import import_module\nfrom pathlib import Path\nimport logging\n\nfrom .role import Context, Role\nfrom .plugin import Plugin\nfrom ..config import MainConfig, RoleConfig, PluginConfig\nfrom ..goal_manager import GoalManager, Goal\nfrom ..snapshot_store import SnapshotStore\nfrom ..model_client import ModelClient\nfrom ..learning_log import LearningLog, create_learning_entry\n\n\nclass Engine:\n    \"\"\"\n    Orchestrates the self-improvement process, managing cycles,\n    goals, roles, and snapshots.\n    \"\"\"\n\n    logger = logging.getLogger(__name__)\n\n    def __init__(self, config: MainConfig):\n        self.config = config\n        self.goal_manager = GoalManager(self.config.engine.goals_path)\n        self.snapshot_store = SnapshotStore(self.config.engine.memory_path)\n        self.model_client = ModelClient(self.config.model)\n        self.learning_log = LearningLog(\n            Path(self.config.engine.memory_path) / \"learning\"\n        )\n\n        # Ensure core directories exist for the project structure\n        Path(self.config.engine.code_dir).mkdir(parents=True, exist_ok=True)\n\n        self.roles = self._load_roles(config.roles)\n        self.plugins = self._load_plugins(config.plugins)\n\n    def _load_roles(self, role_configs: List[RoleConfig]) -> List[Role]:\n        \"\"\"\n        Dynamically loads and instantiates roles based on the role_configs.\n        \"\"\"\n        loaded_roles: List[Role] = []\n        for role_conf in role_configs:\n            try:\n                module = import_module(role_conf.module)\n                role_class = getattr(module, role_conf.class_name)\n                # Pass learning_log to RefineRole, but not to others\n                if role_conf.class_name == \"RefineRole\":\n                    loaded_roles.append(\n                        role_class(\n                            self.config, self.model_client, self.learning_log\n                        )\n                    )\n                else:\n                    loaded_roles.append(\n                        role_class(self.config, self.model_client)\n                    )\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading role '%s' from module '%s': %s\",\n                    role_conf.class_name,\n                    role_conf.module,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_roles\n\n    def _load_plugins(\n        self, plugin_configs: Dict[str, PluginConfig]\n    ) -> Dict[str, Plugin]:\n        \"\"\"\n        Dynamically loads plugins based on the plugin_configs.\n        \"\"\"\n        loaded_plugins: Dict[str, Plugin] = {}\n        for plugin_name, plugin_conf in plugin_configs.items():\n            try:\n                module_path, class_name = plugin_conf.entry_point.rsplit(\n                    \".\", 1\n                )\n                module = import_module(module_path)\n                plugin_class = getattr(module, class_name)\n                loaded_plugins[plugin_name] = plugin_class(self.config)\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading plugin '%s' from entry point '%s': %s\",\n                    plugin_name,\n                    plugin_conf.entry_point,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_plugins\n\n    def run_cycles(self):\n        \"\"\"\n        Main loop for the self-improvement process.\n        \"\"\"\n        self.logger.info(\"Starting self-improvement engine cycles...\")\n\n        while True:\n            goal = self.goal_manager.next_goal()\n            if not goal:\n                self.logger.info(\"No more pending goals. Exiting.\")\n                break\n\n            context = Context(code_dir=self.config.engine.code_dir, goal=goal)\n            goal = cast(Goal, context.goal)  # Ensure goal is correctly typed\n            self.logger.info(\n                \"\\n--- Processing Goal: %s - %s ---\",\n                goal.goal_id,\n                goal.description,\n            )\n\n            loaded_snapshot = self.snapshot_store.load_latest(goal.goal_id)\n            if loaded_snapshot:\n                loaded_snapshot.goal = goal\n                context = loaded_snapshot\n                self.logger.info(\n                    \"Resuming goal '%s' from previous snapshot.\",\n                    goal.goal_id,\n                )\n            else:\n                self.logger.info(\n                    \"Starting new attempt for goal '%s'.\",\n                    goal.goal_id,\n                )\n                context.todos = []\n\n            for attempt in range(self.config.engine.max_cycles):\n                goal = cast(Goal, context.goal)  # Ensure goal is not None\n                self.logger.info(\n                    \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                    goal.goal_id,\n                    attempt + 1,\n                    self.config.engine.max_cycles,\n                )\n\n                # Reset transient states\n                context.patch = None\n                context.test_results = None\n                context.review = None\n                context.accepted = False\n                context.should_abort = False\n\n                # Execute roles\n                for role in self.roles:\n                    self.logger.info(\n                        \"Executing role: %s\", role.__class__.__name__\n                    )\n                    context = role.run(context)\n                    if context.should_abort:\n                        self.logger.warning(\n                            \"Role %s requested abort. Stopping attempt.\",\n                            role.__class__.__name__,\n                        )\n                        break\n\n                self.snapshot_store.record(context)\n\n                # Record learning entry\n                learning_entry = create_learning_entry(\n                    goal=goal.description,\n                    patch=context.patch or \"\",\n                    test_results=context.test_results or {},\n                    review=context.review or \"\",\n                    success=context.accepted,\n                )\n                self.learning_log.record_entry(learning_entry)\n\n                if context.accepted:\n                    self.goal_manager.mark_done(goal.goal_id)\n                    self.logger.info(\n                        \"Goal '%s' completed in %s attempts.\",\n                        goal.goal_id,\n                        attempt + 1,\n                    )\n                    break\n                elif context.should_abort:\n                    self.logger.warning(\n                        \"Goal '%s' aborted after %s attempts.\",\n                        goal.goal_id,\n                        attempt + 1,\n                    )\n                    break  # Move to the next pending goal\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/engine.py",
      "change_type": "modify",
      "description": "Refactor the core goal execution loop in engine.py to support an asynchronous execution model, which is a prerequisite for concurrent processing of independent goals."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/engine.py\n+++ b/src/ai_self_ext_engine/core/engine.py",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}