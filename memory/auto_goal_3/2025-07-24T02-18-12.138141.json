{
  "cycle": null,
  "goal_id": "auto_goal_3",
  "description": "Improve architecture: Plugin architecture and parallel processing improvements",
  "current_code": "# File: src/ai_self_ext_engine/core/engine.py\nfrom typing import List, Dict, cast\nfrom importlib import import_module\nfrom pathlib import Path\nimport logging\n\nfrom .role import Context, Role\nfrom .plugin import Plugin\nfrom ..config import MainConfig, RoleConfig, PluginConfig\nfrom ..goal_manager import GoalManager, Goal\nfrom ..snapshot_store import SnapshotStore\nfrom ..model_client import ModelClient\nfrom ..learning_log import LearningLog, create_learning_entry\n\n\nclass Engine:\n    \"\"\"\n    Orchestrates the self-improvement process, managing cycles,\n    goals, roles, and snapshots.\n    \"\"\"\n\n    logger = logging.getLogger(__name__)\n\n    def __init__(self, config: MainConfig):\n        \"\"\"Initialize the Engine with configuration.\n        \n        Args:\n            config: Main configuration object containing engine settings, paths, and model configuration\n        \"\"\"\n        self.config = config\n        self.goal_manager = GoalManager(self.config.engine.goals_path)\n        self.snapshot_store = SnapshotStore(self.config.engine.memory_path)\n        self.model_client = ModelClient(self.config.model)\n        self.learning_log = LearningLog(\n            Path(self.config.engine.memory_path) / \"learning\"\n        )\n\n        # Ensure core directories exist for the project structure\n        Path(self.config.engine.code_dir).mkdir(parents=True, exist_ok=True)\n\n        self.roles = self._load_roles(config.roles)\n        self.plugins = self._load_plugins(config.plugins)\n\n    def _load_roles(self, role_configs: List[RoleConfig]) -> List[Role]:\n        \"\"\"Dynamically loads and instantiates roles based on the role_configs.\n        \n        Args:\n            role_configs: List of role configuration objects specifying modules and classes to load\n            \n        Returns:\n            List of instantiated role objects ready for execution\n        \"\"\"\n        loaded_roles: List[Role] = []\n        for role_conf in role_configs:\n            try:\n                module = import_module(role_conf.module)\n                role_class = getattr(module, role_conf.class_name)\n                # Pass learning_log to RefineRole, but not to others\n                if role_conf.class_name == \"RefineRole\":\n                    loaded_roles.append(\n                        role_class(self.config, self.model_client, self.learning_log)\n                    )\n                else:\n                    loaded_roles.append(role_class(self.config, self.model_client))\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading role '%s' from module '%s': %s\",\n                    role_conf.class_name,\n                    role_conf.module,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_roles\n\n    def _load_plugins(\n        self, plugin_configs: Dict[str, PluginConfig]\n    ) -> Dict[str, Plugin]:\n        \"\"\"Dynamically loads plugins based on the plugin_configs.\n        \n        Args:\n            plugin_configs: Dictionary mapping plugin names to their configuration objects\n            \n        Returns:\n            Dictionary mapping plugin names to instantiated plugin objects\n        \"\"\"\n        loaded_plugins: Dict[str, Plugin] = {}\n        for plugin_name, plugin_conf in plugin_configs.items():\n            try:\n                module_path, class_name = plugin_conf.entry_point.rsplit(\".\", 1)\n                module = import_module(module_path)\n                plugin_class = getattr(module, class_name)\n                loaded_plugins[plugin_name] = plugin_class(self.config)\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading plugin '%s' from entry point '%s': %s\",\n                    plugin_name,\n                    plugin_conf.entry_point,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_plugins\n\n    def run_cycles(self):\n        \"\"\"Main loop for the self-improvement process.\n        \n        Enhanced with autonomous goal generation. Continuously processes goals from the goal manager,\n        executing them through configured roles until completion or abort. Automatically generates\n        new goals when the queue is empty.\n        \n        Returns:\n            None: This method runs until all goals are processed or autonomous generation fails\n        \"\"\"\n        self.logger.info(\"Starting self-improvement engine cycles...\")\n\n        while True:\n            goal = self._get_next_goal()\n            if not goal:\n                break\n\n            context = self._setup_goal_context(goal)\n            self._execute_goal_attempts(context)\n\n    def _get_next_goal(self) -> Goal | None:\n        \"\"\"Get the next goal to process, with autonomous generation fallback.\n        \n        Returns:\n            Goal | None: The next goal to process, or None if no goals available and generation failed\n        \"\"\"\n        goal = self.goal_manager.next_goal()\n        if not goal:\n            self.logger.info(\n                \"No pending goals found. Attempting autonomous goal generation...\"\n            )\n            if self._attempt_autonomous_goal_generation():\n                return (\n                    self.goal_manager.next_goal()\n                )  # Try again with newly generated goals\n            else:\n                self.logger.info(\n                    \"No more goals available and auto-generation failed. Exiting.\"\n                )\n                return None\n        return goal\n\n    def _setup_goal_context(self, goal: Goal) -> Context:\n        \"\"\"Set up the context for goal processing, handling snapshot restoration.\n        \n        Args:\n            goal: The goal to set up context for\n            \n        Returns:\n            Context: Configured context object ready for goal processing\n        \"\"\"\n        context = Context(code_dir=self.config.engine.code_dir, goal=goal)\n        goal = cast(Goal, context.goal)  # Ensure goal is correctly typed\n\n        self.logger.info(\n            \"\\n--- Processing Goal: %s - %s ---\",\n            goal.goal_id,\n            goal.description,\n        )\n\n        loaded_snapshot = self.snapshot_store.load_latest(goal.goal_id)\n        if loaded_snapshot:\n            loaded_snapshot.goal = goal\n            context = loaded_snapshot\n            self.logger.info(\n                \"Resuming goal '%s' from previous snapshot.\",\n                goal.goal_id,\n            )\n        else:\n            self.logger.info(\n                \"Starting new attempt for goal '%s'.\",\n                goal.goal_id,\n            )\n            context.todos = []\n\n        return context\n\n    def _execute_goal_attempts(self, context: Context) -> None:\n        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n        for attempt in range(self.config.engine.max_cycles):\n            goal = cast(Goal, context.goal)  # Ensure goal is not None\n            self.logger.info(\n                \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                goal.goal_id,\n                attempt + 1,\n                self.config.engine.max_cycles,\n            )\n\n            self._reset_attempt_state(context)\n            result = self._execute_roles(context)\n            self._record_attempt_results(context, goal)\n\n            if result == \"completed\":\n                self.goal_manager.mark_done(goal.goal_id)\n                self.logger.info(\n                    \"Goal '%s' completed in %s attempts.\",\n                    goal.goal_id,\n                    attempt + 1,\n                )\n                break\n            elif result == \"aborted\":\n                self.logger.warning(\n                    \"Goal '%s' aborted after %s attempts.\",\n                    goal.goal_id,\n                    attempt + 1,\n                )\n                break  # Move to the next pending goal\n\n    def _reset_attempt_state(self, context: Context) -> None:\n        \"\"\"Reset transient state for a new attempt.\"\"\"\n        context.patch = None\n        context.test_results = None\n        context.review = None\n        context.accepted = False\n        context.should_abort = False\n\n    def _execute_roles(self, context: Context) -> str:\n        \"\"\"Execute all roles and return the result status.\n        \n        Args:\n            context: The execution context containing goal and state information\n            \n        Returns:\n            str: Status string - \"completed\", \"aborted\", or \"continue\"\n        \"\"\"\n        for role in self.roles:\n            self.logger.info(\"Executing role: %s\", role.__class__.__name__)\n            context = role.run(context)\n            if context.should_abort:\n                self.logger.warning(\n                    \"Role %s requested abort. Stopping attempt.\",\n                    role.__class__.__name__,\n                )\n                return \"aborted\"\n\n        if context.accepted:\n            return \"completed\"\n        return \"continue\"\n\n    def _record_attempt_results(self, context: Context, goal: Goal) -> None:\n        \"\"\"Record snapshot and learning entry for the attempt.\"\"\"\n        self.snapshot_store.record(context)\n\n        # Record learning entry\n        learning_entry = create_learning_entry(\n            goal=goal.description,\n            patch=context.patch or \"\",\n            test_results=context.test_results or {},\n            review=context.review or \"\",\n            success=context.accepted,\n        )\n        self.learning_log.record_entry(learning_entry)\n\n    def _attempt_autonomous_goal_generation(self) -> bool:\n        \"\"\"\n        Attempts to autonomously generate new goals when none are available.\n        Returns True if goals were successfully generated and added.\n        \"\"\"\n        try:\n            self.logger.info(\"Initiating autonomous goal generation...\")\n\n            # Try to load the GoalGenerationRole\n            from ai_self_ext_engine.roles.goal_generation import GoalGenerationRole\n\n            goal_generator = GoalGenerationRole(self.config, self.model_client)\n\n            # Create context for goal generation\n            context = Context(code_dir=self.config.engine.code_dir)\n\n            # Run goal generation\n            context = goal_generator.run(context)\n\n            # Extract generated goals from metadata\n            if \"generated_goals\" in context.metadata:\n                generated_goals = context.metadata[\"generated_goals\"]\n\n                self.logger.info(f\"Generated {len(generated_goals)} autonomous goals\")\n\n                # Add goals to goal manager\n                goals_added = 0\n                for goal_data in generated_goals:\n                    try:\n                        from ai_self_ext_engine.goal_manager import Goal\n\n                        goal = Goal(\n                            goal_id=goal_data[\"id\"],\n                            description=goal_data[\"description\"],\n                            priority=goal_data.get(\"priority\", \"medium\"),\n                            metadata=goal_data.get(\"metadata\", {}),\n                        )\n                        self.goal_manager.add_goal(goal)\n                        goals_added += 1\n                        self.logger.info(f\"Added autonomous goal: {goal.description}\")\n                    except Exception as e:\n                        self.logger.error(f\"Failed to add generated goal: {e}\")\n\n                return goals_added > 0\n            else:\n                self.logger.warning(\n                    \"Goal generation completed but no goals were produced\"\n                )\n                return False\n\n        except ImportError as e:\n            self.logger.error(f\"GoalGenerationRole not available: {e}\")\n            return False\n        except Exception as e:\n            self.logger.error(f\"Autonomous goal generation failed: {e}\")\n            return False\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/engine.py",
      "change_type": "modify",
      "description": "Refactor the core engine's task execution loop to support concurrent or asynchronous processing of operations."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/engine.py\n+++ b/src/ai_self_ext_engine/core/engine.py\n@@ -2,6 +2,7 @@\n from importlib import import_module\n from pathlib import Path\n import logging\n+import asyncio # Added for asynchronous operations\n \n from .role import Context, Role\n from .plugin import Plugin\n@@ -69,7 +70,7 @@\n                 raise  # Re-raise to stop execution\n         return loaded_plugins\n \n-    def run_cycles(self):\n+    async def run_cycles(self): # Changed to async\n         \"\"\"Main loop for the self-improvement process.\n         \n         Enhanced with autonomous goal generation. Continuously processes goals from the goal manager,\n@@ -82,12 +83,12 @@\n         self.logger.info(\"Starting self-improvement engine cycles...\")\n \n         while True:\n-            goal = self._get_next_goal()\n+            goal = await self._get_next_goal() # Await call\n             if not goal:\n                 break\n \n-            context = self._setup_goal_context(goal)\n-            self._execute_goal_attempts(context)\n+            context = await self._setup_goal_context(goal) # Await call\n+            await self._execute_goal_attempts(context) # Await call\n \n     def _get_next_goal(self) -> Goal | None:\n         \"\"\"Get the next goal to process, with autonomous generation fallback.\n@@ -96,12 +97,12 @@\n         Returns:\n             Goal | None: The next goal to process, or None if no goals available and generation failed\n         \"\"\"\n         goal = self.goal_manager.next_goal()\n         if not goal:\n             self.logger.info(\n                 \"No pending goals found. Attempting autonomous goal generation...\"\n             )\n-            if self._attempt_autonomous_goal_generation():\n+            if await self._attempt_autonomous_goal_generation(): # Await call\n                 return (\n                     self.goal_manager.next_goal()\n                 )  # Try again with newly generated goals\n@@ -111,7 +112,7 @@\n                 return None\n         return goal\n \n-    def _setup_goal_context(self, goal: Goal) -> Context:\n+    async def _setup_goal_context(self, goal: Goal) -> Context: # Changed to async\n         \"\"\"Set up the context for goal processing, handling snapshot restoration.\n         \n         Args:\n@@ -141,56 +142,67 @@\n \n         return context\n \n-    def _execute_goal_attempts(self, context: Context) -> None:\n-        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n-        for attempt in range(self.config.engine.max_cycles):\n-            goal = cast(Goal, context.goal)  # Ensure goal is not None\n-            self.logger.info(\n-                \"\\n--- Goal '%s' Attempt %s/%s ---\",\n-                goal.goal_id,\n-                attempt + 1,\n-                self.config.engine.max_cycles,\n-            )\n+    async def _execute_goal_attempts(self, context: Context) -> None: # Changed to async\n+        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\n+\n+        Args:\n+            context: The initial execution context for the goal.\n+        \"\"\"\n+        goal = cast(Goal, context.goal)\n+        for attempt_num in range(1, self.config.engine.max_cycles + 1): # Loop from 1\n+            self._log_attempt_start(goal, attempt_num) # New helper method\n \n             self._reset_attempt_state(context)\n-            result = self._execute_roles(context)\n+            context = await self._execute_roles(context) # Await call; now returns modified context\n             self._record_attempt_results(context, goal)\n \n-            if result == \"completed\":\n-                self.goal_manager.mark_done(goal.goal_id)\n-                self.logger.info(\n-                    \"Goal '%s' completed in %s attempts.\",\n-                    goal.goal_id,\n-                    attempt + 1,\n-                )\n-                break\n-            elif result == \"aborted\":\n-                self.logger.warning(\n-                    \"Goal '%s' aborted after %s attempts.\",\n-                    goal.goal_id,\n-                    attempt + 1,\n-                )\n-                break  # Move to the next pending goal\n+            if self._handle_attempt_outcome(context, goal, attempt_num): # New helper method\n+                return # Goal completed or aborted, stop further attempts\n+\n+        self._handle_goal_failure(goal) # New helper method\n+\n+    def _log_attempt_start(self, goal: Goal, attempt_num: int) -> None:\n+        \"\"\"Logs the start of an attempt for a goal.\"\"\"\n+        self.logger.info(\n+            \"\\n--- Goal '%s' Attempt %s/%s ---\",\n+            goal.goal_id,\n+            attempt_num,\n+            self.config.engine.max_cycles,\n+        )\n+\n+    def _handle_attempt_outcome(self, context: Context, goal: Goal, attempt_num: int) -> bool:\n+        \"\"\"Handles the outcome of a single goal attempt.\n+        Returns True if the goal is completed or aborted, False otherwise.\n+        \"\"\"\n+        if context.accepted:\n+            self.goal_manager.mark_done(goal.goal_id)\n+            self.logger.info(\"Goal '%s' completed in %s attempts.\", goal.goal_id, attempt_num)\n+            return True\n+        elif context.should_abort:\n+            self.logger.warning(\"Goal '%s' aborted after %s attempts.\", goal.goal_id, attempt_num)\n+            self.goal_manager.mark_failed(goal.goal_id) # Aborted goals are considered failed for tracking\n+            return True\n+        return False\n+\n+    def _handle_goal_failure(self, goal: Goal) -> None:\n+        \"\"\"Marks a goal as failed after max attempts and logs the error.\"\"\"\n+        self.logger.error(\n+            \"Goal '%s' failed to complete after %s attempts.\",\n+            goal.goal_id,\n+            self.config.engine.max_cycles,\n+        )\n+        self.goal_manager.mark_failed(goal.goal_id)\n \n     def _reset_attempt_state(self, context: Context) -> None:\n         \"\"\"Reset transient state for a new attempt.\"\"\"\n         context.patch = None\n         context.test_results = None\n         context.review = None\n         context.accepted = False\n         context.should_abort = False\n \n-    def _execute_roles(self, context: Context) -> str:\n-        \"\"\"Execute all roles and return the result status.\n+    async def _execute_roles(self, context: Context) -> Context: # Changed to async, returns Context\n+        \"\"\"Execute all roles and return the modified context.\n         \n         Args:\n             context: The execution context containing goal and state information\n             \n         Returns:\n-            str: Status string - \"completed\", \"aborted\", or \"continue\"\n+            Context: The modified context after all roles have run, or if an abort was requested.\n         \"\"\"\n         for role in self.roles:\n             self.logger.info(\"Executing role: %s\", role.__class__.__name__)\n-            context = role.run(context)\n+            context = await role.run(context) # Await role.run\n             if context.should_abort:\n                 self.logger.warning(\n                     \"Role %s requested abort. Stopping attempt.\",\n                     role.__class__.__name__,\n                 )\n-                return \"aborted\"\n-\n-        if context.accepted:\n-            return \"completed\"\n-        return \"continue\"\n+                return context # Return early with the aborted context\n+\n+        return context # Return the final context\n \n     def _record_attempt_results(self, context: Context, goal: Goal) -> None:\n         \"\"\"Record snapshot and learning entry for the attempt.\"\"\"\n@@ -205,7 +227,7 @@\n         )\n         self.learning_log.record_entry(learning_entry)\n \n-    def _attempt_autonomous_goal_generation(self) -> bool:\n+    async def _attempt_autonomous_goal_generation(self) -> bool: # Changed to async\n         \"\"\"\n         Attempts to autonomously generate new goals when none are available.\n         Returns True if goals were successfully generated and added.\n@@ -220,7 +242,7 @@\n             context = Context(code_dir=self.config.engine.code_dir)\n \n             # Run goal generation\n-            context = goal_generator.run(context)\n+            context = await goal_generator.run(context) # Await goal_generator.run\n \n             # Extract generated goals from metadata\n             if \"generated_goals\" in context.metadata:",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}