{
  "cycle": null,
  "goal_id": "auto_goal_3",
  "description": "Improve architecture: Plugin architecture and parallel processing improvements",
  "current_code": "# File: src/ai_self_ext_engine/core/plugin_manager.py\nimport importlib.util\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Type, Any, List, Optional\n\nlogger = logging.getLogger(__name__)\n\n# Define a simple base class for plugins\nclass BasePlugin:\n    \"\"\"\n    Base class for all plugins managed by the PluginManager.\n    Plugins should inherit from this class and implement the required methods.\n    \"\"\"\n    name: str = \"UnnamedPlugin\"\n    description: str = \"A generic plugin.\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initializes the base plugin. Concrete plugins can extend this to accept\n        configuration or dependencies.\n        \"\"\"\n        pass\n\n    async def execute(self, context: Any) -> Any:\n        \"\"\"\n        Execute the plugin's primary action.\n        This method must be implemented by concrete plugin classes.\n        It is designed to be async to facilitate future parallel execution.\n\n        Args:\n            context: The current execution context, which can be modified by the plugin.\n\n        Returns:\n            The updated execution context.\n        \"\"\"\n        raise NotImplementedError(\"Plugin must implement the 'execute' method.\")\n\n    def __repr__(self):\n        return f\"<Plugin: {self.name}>\"\n\nclass PluginManager:\n    \"\"\"\n    Manages the loading, registration, and access to various plugins.\n    Lays the groundwork for improved plugin architecture and facilitates future\n    parallel execution of plugin actions by managing plugins that conform to\n    an async interface (`BasePlugin`).\n    \"\"\"\n    def __init__(self):\n        self._plugins: Dict[str, BasePlugin] = {}\n        logger.debug(\"PluginManager initialized.\")\n\n    def register_plugin(self, plugin_instance: BasePlugin):\n        \"\"\"\n        Registers a plugin instance with the manager.\n\n        Args:\n            plugin_instance: An instance of a class inheriting from BasePlugin.\n        \"\"\"\n        if not isinstance(plugin_instance, BasePlugin):\n            raise TypeError(f\"Provided object is not an instance of BasePlugin: {type(plugin_instance)}\")\n\n        if plugin_instance.name in self._plugins:\n            logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n\n        self._plugins[plugin_instance.name] = plugin_instance\n        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n\n    def get_plugin(self, name: str) -> Optional[BasePlugin]:\n        \"\"\"\n        Retrieves a registered plugin by its name.\n\n        Args:\n            name: The name of the plugin to retrieve.\n\n        Returns:\n            The BasePlugin instance if found, otherwise None.\n        \"\"\"\n        return self._plugins.get(name)\n\n    def get_all_plugins(self) -> Dict[str, BasePlugin]:\n        \"\"\"\n        Retrieves a copy of all registered plugins, keyed by their names.\n        \"\"\"\n        return self._plugins.copy()\n\n    def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n        \"\"\"\n        Scans a directory for Python files, attempts to import them as modules,\n        and registers classes inheriting from `plugin_base_class` as plugins.\n        \"\"\"\n        if not plugin_dir.is_dir():\n            logger.warning(f\"Plugin directory not found or is not a directory: {plugin_dir}\")\n            return\n\n        logger.info(f\"Loading plugins from directory: {plugin_dir}\")\n        for filepath in plugin_dir.glob(\"*.py\"):\n            if filepath.name == \"__init__.py\":\n\n# AI-generated improvements:\n    # A dictionary to expose specific capabilities (e.g., tools, data handlers)\n    capabilities: Dict[str, Any] = {}\n        # Store capabilities exposed by registered plugins\n        self._all_plugin_capabilities: Dict[str, Dict[str, Any]] = {}\n        # Store the plugin's capabilities\n        if plugin_instance.capabilities:\n            self._all_plugin_capabilities[plugin_instance.name] = plugin_instance.capabilities\n            logger.info(f\"Plugin '{plugin_instance.name}' registered with capabilities: {list(plugin_instance.capabilities.keys())}\")\n        else:\n            logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n    def get_plugin_capabilities(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieves the capabilities exposed by a specific registered plugin.\n        Args:\n            plugin_name: The name of the plugin.\n        Returns:\n            A dictionary of capabilities if the plugin is found and exposes any, otherwise None.\n        \"\"\"\n        return self._all_plugin_capabilities.get(plugin_name)\n    def get_all_plugin_capabilities(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Retrieves a copy of all capabilities registered by all plugins,\n        keyed by plugin name.\n        Returns:\n            A dictionary where keys are plugin names and values are their\n            respective capabilities dictionaries.\n        \"\"\"\n        return self._all_plugin_capabilities.copy()\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/plugin_manager.py",
      "change_type": "modify",
      "description": "Refactor PluginManager to support asynchronous plugin loading and execution, enabling future parallel processing capabilities."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/plugin_manager.py\n+++ b/src/ai_self_ext_engine/core/plugin_manager.py\n@@ -1,6 +1,7 @@\n import importlib.util\n import logging\n from pathlib import Path\n-from typing import Dict, Type, Any, List, Optional\n+import inspect # Added for runtime class inspection\n+import asyncio # Added for asynchronous execution\n+from typing import Dict, Type, Any, List, Optional\n \n logger = logging.getLogger(__name__)\n \n@@ -30,12 +31,16 @@\n         Returns:\n             The updated execution context.\n         \"\"\"\n         raise NotImplementedError(\"Plugin must implement the 'execute' method.\")\n \n     def __repr__(self):\n         return f\"<Plugin: {self.name}>\"\n \n+# A dictionary to expose specific capabilities (e.g., tools, data handlers)\n+    capabilities: Dict[str, Any] = {}\n+\n class PluginManager:\n     \"\"\"\n     Manages the loading, registration, and access to various plugins.\n     Lays the groundwork for improved plugin architecture and facilitates future\n     parallel execution of plugin actions by managing plugins that conform to\n     an async interface (`BasePlugin`).\n     \"\"\"\n     def __init__(self):\n         self._plugins: Dict[str, BasePlugin] = {}\n+        # Store capabilities exposed by registered plugins\n+        self._all_plugin_capabilities: Dict[str, Dict[str, Any]] = {}\n         logger.debug(\"PluginManager initialized.\")\n \n     def register_plugin(self, plugin_instance: BasePlugin):\n@@ -50,7 +55,11 @@\n             logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n \n         self._plugins[plugin_instance.name] = plugin_instance\n-        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n+        # Store the plugin's capabilities\n+        if plugin_instance.capabilities:\n+            self._all_plugin_capabilities[plugin_instance.name] = plugin_instance.capabilities\n+            logger.info(f\"Plugin '{plugin_instance.name}' registered with capabilities: {list(plugin_instance.capabilities.keys())}\")\n+        else:\n+            logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n \n     def get_plugin(self, name: str) -> Optional[BasePlugin]:\n         \"\"\"\n@@ -69,21 +78,98 @@\n         \"\"\"\n         return self._plugins.copy()\n \n+    def get_plugin_capabilities(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n+        \"\"\"\n+        Retrieves the capabilities exposed by a specific registered plugin.\n+        Args:\n+            plugin_name: The name of the plugin.\n+        Returns:\n+            A dictionary of capabilities if the plugin is found and exposes any, otherwise None.\n+        \"\"\"\n+        return self._all_plugin_capabilities.get(plugin_name)\n+\n+    def get_all_plugin_capabilities(self) -> Dict[str, Dict[str, Any]]:\n+        \"\"\"\n+        Retrieves a copy of all capabilities registered by all plugins,\n+        keyed by plugin name.\n+        Returns:\n+            A dictionary where keys are plugin names and values are their\n+            respective capabilities dictionaries.\n+        \"\"\"\n+        return self._all_plugin_capabilities.copy()\n+\n     def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n         \"\"\"\n         Scans a directory for Python files, attempts to import them as modules,\n         and registers classes inheriting from `plugin_base_class` as plugins.\n         \"\"\"\n         if not plugin_dir.is_dir():\n             logger.warning(f\"Plugin directory not found or is not a directory: {plugin_dir}\")\n             return\n \n         logger.info(f\"Loading plugins from directory: {plugin_dir}\")\n         for filepath in plugin_dir.glob(\"*.py\"):\n             if filepath.name == \"__init__.py\":\n-\n-# AI-generated improvements:\n-    # A dictionary to expose specific capabilities (e.g., tools, data handlers)\n-    capabilities: Dict[str, Any] = {}\n-        # Store capabilities exposed by registered plugins\n-        self._all_plugin_capabilities: Dict[str, Dict[str, Any]] = {}\n-        # Store the plugin's capabilities\n-        if plugin_instance.capabilities:\n-            self._all_plugin_capabilities[plugin_instance.name] = plugin_instance.capabilities\n-            logger.info(f\"Plugin '{plugin_instance.name}' registered with capabilities: {list(plugin_instance.capabilities.keys())}\")\n-        else:\n-            logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n-    def get_plugin_capabilities(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n-        \"\"\"\n-        Retrieves the capabilities exposed by a specific registered plugin.\n-        Args:\n-            plugin_name: The name of the plugin.\n-        Returns:\n-            A dictionary of capabilities if the plugin is found and exposes any, otherwise None.\n-        \"\"\"\n-        return self._all_plugin_capabilities.get(plugin_name)\n-    def get_all_plugin_capabilities(self) -> Dict[str, Dict[str, Any]]:\n-        \"\"\"\n-        Retrieves a copy of all capabilities registered by all plugins,\n-        keyed by plugin name.\n-        Returns:\n-            A dictionary where keys are plugin names and values are their\n-            respective capabilities dictionaries.\n-        \"\"\"\n-        return self._all_plugin_capabilities.copy()\n+                continue # Skip __init__.py files\n+\n+            module_name = filepath.stem # Get file name without extension\n+            spec = importlib.util.spec_from_file_location(module_name, filepath)\n+            if spec is None:\n+                logger.warning(f\"Could not get module spec for {filepath}, skipping.\")\n+                continue\n+\n+            try:\n+                module = importlib.util.module_from_spec(spec)\n+                if spec.loader:\n+                    spec.loader.exec_module(module)\n+                else:\n+                    logger.warning(f\"No loader found for module spec {module_name}, skipping {filepath}.\")\n+                    continue\n+\n+                for name, obj in inspect.getmembers(module):\n+                    # Check if it's a class, inherits from plugin_base_class, and is not the base class itself\n+                    if inspect.isclass(obj) and issubclass(obj, plugin_base_class) and obj is not plugin_base_class:\n+                        try:\n+                            # Instantiate the plugin. Assuming concrete plugins can be instantiated without args\n+                            # or have sensible defaults.\n+                            plugin_instance = obj()\n+                            self.register_plugin(plugin_instance)\n+                        except TypeError as te:\n+                            logger.error(f\"Failed to instantiate plugin '{name}' from '{filepath}' due to TypeError: {te}. Check its __init__ method for missing arguments.\")\n+                        except Exception as e:\n+                            logger.error(f\"An unexpected error occurred instantiating plugin '{name}' from '{filepath}': {e}\", exc_info=True)\n+\n+            except Exception as e:\n+                logger.error(f\"Failed to load module {module_name} from {filepath}: {e}\", exc_info=True)\n+\n+    async def execute_plugin_action(self, plugin_name: str, context: Any) -> Any:\n+        \"\"\"\n+        Executes the primary action of a single registered plugin asynchronously.\n+\n+        Args:\n+            plugin_name: The name of the plugin to execute.\n+            context: The current execution context to pass to the plugin.\n+\n+        Returns:\n+            The updated execution context returned by the plugin, or the original\n+            context if the plugin is not found or fails.\n+        \"\"\"\n+        plugin = self.get_plugin(plugin_name)\n+        if not plugin:\n+            logger.warning(f\"Plugin '{plugin_name}' not found. Cannot execute action.\")\n+            return context # Return original context if plugin not found\n+\n+        logger.info(f\"Executing plugin '{plugin_name}'...\")\n+        try:\n+            # Await the asynchronous execute method of the plugin\n+            updated_context = await plugin.execute(context)\n+            logger.info(f\"Plugin '{plugin_name}' executed successfully.\")\n+            return updated_context\n+        except NotImplementedError:\n+            logger.error(f\"Plugin '{plugin_name}' has not implemented the 'execute' method.\")\n+            return context # Return original context on error\n+        except Exception as e:\n+            logger.error(f\"Error executing plugin '{plugin_name}': {e}\", exc_info=True)\n+            return context # Return original context on error\n+\n+    async def execute_plugins_in_parallel(self, plugin_names: List[str], context: Any) -> Dict[str, Any]:\n+        \"\"\"\n+        Executes a list of plugins concurrently and returns their results.\n+        Note: This method passes the *same initial context object* to all plugins.\n+        If plugins modify the context in-place, concurrent modifications may lead\n+        to race conditions. A more robust solution might involve deep-copying contexts\n+        or having plugins return diffs to be merged by a higher-level orchestrator.\n+\n+        Args:\n+            plugin_names: A list of names of plugins to execute.\n+            context: The current execution context.\n+\n+        Returns:\n+            A dictionary where keys are plugin names and values are the updated\n+            contexts returned by each plugin's execution. Plugins that fail or are\n+            not found will return the original context (or None if task failed).\n+        \"\"\"\n+        tasks = []\n+        # Prepare tasks, capturing plugin_name for result mapping\n+        for plugin_name in plugin_names:\n+            plugin = self.get_plugin(plugin_name)\n+            if plugin:\n+                tasks.append((plugin_name, self.execute_plugin_action(plugin_name, context)))\n+            else:\n+                logger.warning(f\"Plugin '{plugin_name}' not found for parallel execution. Skipping.\")\n+                # We don't add to tasks, but need to account for it in results (implicitly skipped)\n+\n+        if not tasks:\n+            return {} # No plugins to execute\n+\n+        # Use asyncio.gather to run tasks concurrently\n+        # We pass a list of coroutines, so we need to extract them from the (name, coroutine) tuples\n+        coroutine_tasks = [task_coro for _, task_coro in tasks]\n+        \n+        # Run all collected tasks concurrently. execute_plugin_action already handles its own exceptions.\n+        results_contexts = await asyncio.gather(*coroutine_tasks)\n+\n+        # Map results back to plugin names\n+        final_results: Dict[str, Any] = {}\n+        for i, (plugin_name, _) in enumerate(tasks):\n+            final_results[plugin_name] = results_contexts[i]\n+        \n+        return final_results",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}