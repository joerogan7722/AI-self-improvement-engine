{
  "cycle": null,
  "goal_id": "auto_goal_3",
  "description": "Improve architecture: Plugin architecture and parallel processing improvements",
  "current_code": "# File: src/ai_self_ext_engine/core/plugin_manager.py\nimport importlib.util\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Type, Any, List, Optional\n\nlogger = logging.getLogger(__name__)\n\n# Define a simple base class for plugins\nclass BasePlugin:\n    \"\"\"\n    Base class for all plugins managed by the PluginManager.\n    Plugins should inherit from this class and implement the required methods.\n    \"\"\"\n    name: str = \"UnnamedPlugin\"\n    description: str = \"A generic plugin.\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initializes the base plugin. Concrete plugins can extend this to accept\n        configuration or dependencies.\n        \"\"\"\n        pass\n\n    async def execute(self, context: Any) -> Any:\n        \"\"\"\n        Execute the plugin's primary action.\n        This method must be implemented by concrete plugin classes.\n        It is designed to be async to facilitate future parallel execution.\n\n        Args:\n            context: The current execution context, which can be modified by the plugin.\n\n        Returns:\n            The updated execution context.\n        \"\"\"\n        raise NotImplementedError(\"Plugin must implement the 'execute' method.\")\n\n    def __repr__(self):\n        return f\"<Plugin: {self.name}>\"\n\nclass PluginManager:\n    \"\"\"\n    Manages the loading, registration, and access to various plugins.\n    Lays the groundwork for improved plugin architecture and facilitates future\n    parallel execution of plugin actions by managing plugins that conform to\n    an async interface (`BasePlugin`).\n    \"\"\"\n    def __init__(self):\n        self._plugins: Dict[str, BasePlugin] = {}\n        logger.debug(\"PluginManager initialized.\")\n\n    def register_plugin(self, plugin_instance: BasePlugin):\n        \"\"\"\n        Registers a plugin instance with the manager.\n\n        Args:\n            plugin_instance: An instance of a class inheriting from BasePlugin.\n        \"\"\"\n        if not isinstance(plugin_instance, BasePlugin):\n            raise TypeError(f\"Provided object is not an instance of BasePlugin: {type(plugin_instance)}\")\n\n        if plugin_instance.name in self._plugins:\n            logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n\n        self._plugins[plugin_instance.name] = plugin_instance\n        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n\n    def get_plugin(self, name: str) -> Optional[BasePlugin]:\n        \"\"\"\n        Retrieves a registered plugin by its name.\n\n        Args:\n            name: The name of the plugin to retrieve.\n\n        Returns:\n            The BasePlugin instance if found, otherwise None.\n        \"\"\"\n        return self._plugins.get(name)\n\n    def get_all_plugins(self) -> Dict[str, BasePlugin]:\n        \"\"\"\n        Retrieves a copy of all registered plugins, keyed by their names.\n        \"\"\"\n        return self._plugins.copy()\n\n    def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n        \"\"\"\n        Scans a directory for Python files, attempts to import them as modules,\n        and registers classes inheriting from `plugin_base_class` as plugins.\n        \"\"\"\n        if not plugin_dir.is_dir():\n            logger.warning(f\"Plugin directory not found or is not a directory: {plugin_dir}\")\n            return\n\n        logger.info(f\"Loading plugins from directory: {plugin_dir}\")\n        for filepath in plugin_dir.glob(\"*.py\"):\n            if filepath.name == \"__init__.py\":\n\n# AI-generated improvements:\n    # A dictionary to expose specific capabilities (e.g., tools, data handlers)\n    capabilities: Dict[str, Any] = {}\n        # Store capabilities exposed by registered plugins\n        self._all_plugin_capabilities: Dict[str, Dict[str, Any]] = {}\n        # Store the plugin's capabilities\n        if plugin_instance.capabilities:\n            self._all_plugin_capabilities[plugin_instance.name] = plugin_instance.capabilities\n            logger.info(f\"Plugin '{plugin_instance.name}' registered with capabilities: {list(plugin_instance.capabilities.keys())}\")\n        else:\n            logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n    def get_plugin_capabilities(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Retrieves the capabilities exposed by a specific registered plugin.\n        Args:\n            plugin_name: The name of the plugin.\n        Returns:\n            A dictionary of capabilities if the plugin is found and exposes any, otherwise None.\n        \"\"\"\n        return self._all_plugin_capabilities.get(plugin_name)\n    def get_all_plugin_capabilities(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Retrieves a copy of all capabilities registered by all plugins,\n        keyed by plugin name.\n        Returns:\n            A dictionary where keys are plugin names and values are their\n            respective capabilities dictionaries.\n        \"\"\"\n        return self._all_plugin_capabilities.copy()\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/plugin_manager.py",
      "change_type": "modify",
      "description": "Refactor PluginManager to support asynchronous plugin loading and execution, enabling parallel processing of plugin operations."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/plugin_manager.py\n+++ b/src/ai_self_ext_engine/core/plugin_manager.py\n@@ -3,6 +3,7 @@\n import logging\n from pathlib import Path\n from typing import Dict, Type, Any, List, Optional\n+import asyncio\n\n logger = logging.getLogger(__name__)\n\n@@ -10,6 +11,7 @@\n class BasePlugin:\n     \"\"\"\n     Base class for all plugins managed by the PluginManager.\n     Plugins should inherit from this class and implement the required methods.\n     \"\"\"\n+    capabilities: Dict[str, Any] = {}\n     name: str = \"UnnamedPlugin\"\n     description: str = \"A generic plugin.\"\n \n@@ -40,6 +42,7 @@\n     parallel execution of plugin actions by managing plugins that conform to\n     an async interface (`BasePlugin`).\n     \"\"\"\n     def __init__(self):\n         self._plugins: Dict[str, BasePlugin] = {}\n+        self._all_plugin_capabilities: Dict[str, Dict[str, Any]] = {}\n         logger.debug(\"PluginManager initialized.\")\n \n     def register_plugin(self, plugin_instance: BasePlugin):\n@@ -53,8 +56,14 @@\n         if plugin_instance.name in self._plugins:\n             logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n \n         self._plugins[plugin_instance.name] = plugin_instance\n-        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n+        # Store the plugin's capabilities\n+        if plugin_instance.capabilities:\n+            self._all_plugin_capabilities[plugin_instance.name] = plugin_instance.capabilities\n+            logger.info(f\"Plugin '{plugin_instance.name}' registered with capabilities: {list(plugin_instance.capabilities.keys())}\")\n+        else:\n+            logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n \n     def get_plugin(self, name: str) -> Optional[BasePlugin]:\n         \"\"\"\n@@ -74,21 +83,42 @@\n         \"\"\"\n         return self._plugins.copy()\n \n-    def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n+    def get_plugin_capabilities(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n         \"\"\"\n-        Scans a directory for Python files, attempts to import them as modules,\n-        and registers classes inheriting from `plugin_base_class` as plugins.\n+        Retrieves the capabilities exposed by a specific registered plugin.\n+        Args:\n+            plugin_name: The name of the plugin.\n+        Returns:\n+            A dictionary of capabilities if the plugin is found and exposes any, otherwise None.\n         \"\"\"\n+        return self._all_plugin_capabilities.get(plugin_name)\n+\n+    def get_all_plugin_capabilities(self) -> Dict[str, Dict[str, Any]]:\n+        \"\"\"\n+        Retrieves a copy of all capabilities registered by all plugins,\n+        keyed by plugin name.\n+        Returns:\n+            A dictionary where keys are plugin names and values are their\n+            respective capabilities dictionaries.\n+        \"\"\"\n+        return self._all_plugin_capabilities.copy()\n+\n+    async def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n+        \"\"\"\n+        Scans a directory for Python files, attempts to import them as modules,\n+        and registers classes inheriting from `plugin_base_class` as plugins.\n+        This method is async to facilitate future parallel loading or async plugin initialization.\n+        \"\"\"\n         if not plugin_dir.is_dir():\n             logger.warning(f\"Plugin directory not found or is not a directory: {plugin_dir}\")\n             return\n \n         logger.info(f\"Loading plugins from directory: {plugin_dir}\")\n         for filepath in plugin_dir.glob(\"*.py\"):\n             if filepath.name == \"__init__.py\":\n-\n-# AI-generated improvements:\n-    # A dictionary to expose specific capabilities (e.g., tools, data handlers)\n-    capabilities: Dict[str, Any] = {}\n-        # Store capabilities exposed by registered plugins\n-        self._all_plugin_capabilities: Dict[str, Dict[str, Any]] = {}\n-        # Store the plugin's capabilities\n-        if plugin_instance.capabilities:\n-            self._all_plugin_capabilities[plugin_instance.name] = plugin_instance.capabilities\n-            logger.info(f\"Plugin '{plugin_instance.name}' registered with capabilities: {list(plugin_instance.capabilities.keys())}\")\n-        else:\n-            logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n-    def get_plugin_capabilities(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n-        \"\"\"\n-        Retrieves the capabilities exposed by a specific registered plugin.\n-        Args:\n-            plugin_name: The name of the plugin.\n-        Returns:\n-            A dictionary of capabilities if the plugin is found and exposes any, otherwise None.\n-        \"\"\"\n-        return self._all_plugin_capabilities.get(plugin_name)\n-    def get_all_plugin_capabilities(self) -> Dict[str, Dict[str, Any]]:\n-        \"\"\"\n-        Retrieves a copy of all capabilities registered by all plugins,\n-        keyed by plugin name.\n-        Returns:\n-            A dictionary where keys are plugin names and values are their\n-            respective capabilities dictionaries.\n-        \"\"\"\n-        return self._all_plugin_capabilities.copy()\n+                continue # Skip __init__.py files\n+\n+            module_name = filepath.stem\n+            spec = importlib.util.spec_from_file_location(module_name, filepath)\n+            if spec and spec.loader:\n+                try:\n+                    module = importlib.util.module_from_spec(spec)\n+                    spec.loader.exec_module(module)\n+                    for name, obj in module.__dict__.items():\n+                        if isinstance(obj, type) and issubclass(obj, plugin_base_class) and obj is not plugin_base_class:\n+                            # Instantiate the plugin and register it\n+                            plugin_instance = obj() # Assuming plugins can be instantiated without args, or with default args\n+                            self.register_plugin(plugin_instance)\n+                except Exception as e:\n+                    logger.error(f\"Failed to load plugin from {filepath}: {e}\", exc_info=True)",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}