{
  "cycle": null,
  "goal_id": "auto_goal_3",
  "description": "Improve architecture: Plugin architecture and parallel processing improvements",
  "current_code": "# File: src/ai_self_ext_engine/core/plugin_manager.py\nimport importlib.util\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Type, Any, List, Optional\n\nlogger = logging.getLogger(__name__)\n\n# Define a simple base class for plugins\nclass BasePlugin:\n    \"\"\"\n    Base class for all plugins managed by the PluginManager.\n    Plugins should inherit from this class and implement the required methods.\n    \"\"\"\n    name: str = \"UnnamedPlugin\"\n    description: str = \"A generic plugin.\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initializes the base plugin. Concrete plugins can extend this to accept\n        configuration or dependencies.\n        \"\"\"\n        pass\n\n    async def execute(self, context: Any) -> Any:\n        \"\"\"\n        Execute the plugin's primary action.\n        This method must be implemented by concrete plugin classes.\n        It is designed to be async to facilitate future parallel execution.\n\n        Args:\n            context: The current execution context, which can be modified by the plugin.\n\n        Returns:\n            The updated execution context.\n        \"\"\"\n        raise NotImplementedError(\"Plugin must implement the 'execute' method.\")\n\n    def __repr__(self):\n        return f\"<Plugin: {self.name}>\"\n\nclass PluginManager:\n    \"\"\"\n    Manages the loading, registration, and access to various plugins.\n    Lays the groundwork for improved plugin architecture and facilitates future\n    parallel execution of plugin actions by managing plugins that conform to\n    an async interface (`BasePlugin`).\n    \"\"\"\n    def __init__(self):\n        self._plugins: Dict[str, BasePlugin] = {}\n        logger.debug(\"PluginManager initialized.\")\n\n    def register_plugin(self, plugin_instance: BasePlugin):\n        \"\"\"\n        Registers a plugin instance with the manager.\n\n        Args:\n            plugin_instance: An instance of a class inheriting from BasePlugin.\n        \"\"\"\n        if not isinstance(plugin_instance, BasePlugin):\n            raise TypeError(f\"Provided object is not an instance of BasePlugin: {type(plugin_instance)}\")\n\n        if plugin_instance.name in self._plugins:\n            logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n\n        self._plugins[plugin_instance.name] = plugin_instance\n        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n\n    def get_plugin(self, name: str) -> Optional[BasePlugin]:\n        \"\"\"\n        Retrieves a registered plugin by its name.\n\n        Args:\n            name: The name of the plugin to retrieve.\n\n        Returns:\n            The BasePlugin instance if found, otherwise None.\n        \"\"\"\n        return self._plugins.get(name)\n\n    def get_all_plugins(self) -> Dict[str, BasePlugin]:\n        \"\"\"\n        Retrieves a copy of all registered plugins, keyed by their names.\n        \"\"\"\n        return self._plugins.copy()\n\n    def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n        \"\"\"\n        Scans a directory for Python files, attempts to import them as modules,\n        and registers classes inheriting from `plugin_base_class` as plugins.\n        \"\"\"\n        if not plugin_dir.is_dir():\n            logger.warning(f\"Plugin directory not found or is not a directory: {plugin_dir}\")\n            return\n\n        logger.info(f\"Loading plugins from directory: {plugin_dir}\")\n        for filepath in plugin_dir.glob(\"*.py\"):\n            if filepath.name == \"__init__.py\":\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/plugin_manager.py",
      "change_type": "modify",
      "description": "Integrate an execution pool (e.g., ThreadPoolExecutor) into PluginManager to enable asynchronous/parallel plugin method execution."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/plugin_manager.py\n+++ b/src/ai_self_ext_engine/core/plugin_manager.py\n@@ -1,6 +1,8 @@\n import importlib.util\n import logging\n from pathlib import Path\n+import asyncio\n+from concurrent.futures import ThreadPoolExecutor\n from typing import Dict, Type, Any, List, Optional\n \n logger = logging.getLogger(__name__)\n@@ -12,12 +14,14 @@\n     \"\"\"\n     name: str = \"UnnamedPlugin\"\n     description: str = \"A generic plugin.\"\n+    _executor: Optional[ThreadPoolExecutor] = None\n \n-    def __init__(self, **kwargs):\n+    def __init__(self, executor: Optional[ThreadPoolExecutor] = None, **kwargs):\n         \"\"\"\n         Initializes the base plugin. Concrete plugins can extend this to accept\n         configuration or dependencies.\n         \"\"\"\n+        self._executor = executor\n         pass\n \n     async def execute(self, context: Any) -> Any:\n@@ -32,6 +36,16 @@\n         \"\"\"\n         raise NotImplementedError(\"Plugin must implement the 'execute' method.\")\n \n+    async def run_cpu_bound(self, func, *args, **kwargs):\n+        \"\"\"\n+        Helper for plugins to run synchronous, CPU-bound tasks in the shared\n+        ThreadPoolExecutor provided by the PluginManager.\n+        \"\"\"\n+        if self._executor is None:\n+            raise RuntimeError(\"Executor not provided to plugin. Cannot run CPU-bound task.\")\n+        loop = asyncio.get_running_loop()\n+        return await loop.run_in_executor(self._executor, func, *args, **kwargs)\n+\n     def __repr__(self):\n         return f\"<Plugin: {self.name}>\"\n \n@@ -42,7 +56,22 @@\n     an async interface (`BasePlugin`).\n     \"\"\"\n     def __init__(self):\n+        import os\n         self._plugins: Dict[str, BasePlugin] = {}\n+        # Initialize an executor for CPU-bound tasks if needed by plugins,\n+        # and for potential parallel execution of multiple plugins later.\n+        # Use max_workers slightly more than CPU count to allow for some blocking I/O if threads are waiting\n+        # Fallback to 4 if os.cpu_count() is None or 0.\n+        max_workers = os.cpu_count() * 2 if os.cpu_count() else 4\n+        self._executor = ThreadPoolExecutor(max_workers=max_workers)\n         logger.debug(\"PluginManager initialized.\")\n \n+    def close(self):\n+        \"\"\"Shuts down the internal thread pool executor.\"\"\"\n+        if self._executor:\n+            logger.info(\"Shutting down plugin executor.\")\n+            self._executor.shutdown(wait=True)\n+            self._executor = None\n+\n     def register_plugin(self, plugin_instance: BasePlugin):\n         \"\"\"\n         Registers a plugin instance with the manager.\n@@ -54,6 +83,10 @@\n \n         if plugin_instance.name in self._plugins:\n             logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n+        \n+        # Inject the executor into the plugin instance if it hasn't been set\n+        if plugin_instance._executor is None:\n+            plugin_instance._executor = self._executor\n \n         self._plugins[plugin_instance.name] = plugin_instance\n         logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n@@ -75,6 +108,18 @@\n         \"\"\"\n         return self._plugins.copy()\n \n+    async def execute_plugin(self, name: str, context: Any) -> Any:\n+        \"\"\"\n+        Executes a registered plugin's primary action asynchronously.\n+\n+        Args:\n+            name: The name of the plugin to execute.\n+            context: The execution context to pass to the plugin.\n+        \"\"\"\n+        plugin = self.get_plugin(name)\n+        if not plugin:\n+            raise ValueError(f\"Plugin '{name}' not found.\")\n+        return await plugin.execute(context)\n+\n     def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n         \"\"\"\n         Scans a directory for Python files, attempts to import them as modules,",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}