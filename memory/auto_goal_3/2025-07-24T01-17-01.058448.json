{
  "cycle": null,
  "goal_id": "auto_goal_3",
  "description": "Improve architecture: Plugin architecture and parallel processing improvements",
  "current_code": "",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/plugin_manager.py",
      "change_type": "add",
      "description": "Implement a `PluginManager` class responsible for loading, registering, and providing access to various plugins, laying the groundwork for improved plugin architecture and facilitating future parallel execution of plugin actions.",
      "line_start": 1,
      "line_end": 1
    }
  ],
  "patch": "--- /dev/null\n+++ b/src/ai_self_ext_engine/core/plugin_manager.py\n@@ -0,0 +1,97 @@\n+import importlib.util\n+import logging\n+from pathlib import Path\n+from typing import Dict, Type, Any, List, Optional\n+\n+logger = logging.getLogger(__name__)\n+\n+# Define a simple base class for plugins\n+class BasePlugin:\n+    \"\"\"\n+    Base class for all plugins managed by the PluginManager.\n+    Plugins should inherit from this class and implement the required methods.\n+    \"\"\"\n+    name: str = \"UnnamedPlugin\"\n+    description: str = \"A generic plugin.\"\n+\n+    def __init__(self, **kwargs):\n+        \"\"\"\n+        Initializes the base plugin. Concrete plugins can extend this to accept\n+        configuration or dependencies.\n+        \"\"\"\n+        pass\n+\n+    async def execute(self, context: Any) -> Any:\n+        \"\"\"\n+        Execute the plugin's primary action.\n+        This method must be implemented by concrete plugin classes.\n+        It is designed to be async to facilitate future parallel execution.\n+        \n+        Args:\n+            context: The current execution context, which can be modified by the plugin.\n+\n+        Returns:\n+            The updated execution context.\n+        \"\"\"\n+        raise NotImplementedError(\"Plugin must implement the 'execute' method.\")\n+\n+    def __repr__(self):\n+        return f\"<Plugin: {self.name}>\"\n+\n+class PluginManager:\n+    \"\"\"\n+    Manages the loading, registration, and access to various plugins.\n+    Lays the groundwork for improved plugin architecture and facilitates future\n+    parallel execution of plugin actions by managing plugins that conform to\n+    an async interface (`BasePlugin`).\n+    \"\"\"\n+    def __init__(self):\n+        self._plugins: Dict[str, BasePlugin] = {}\n+        logger.debug(\"PluginManager initialized.\")\n+\n+    def register_plugin(self, plugin_instance: BasePlugin):\n+        \"\"\"\n+        Registers a plugin instance with the manager.\n+        \n+        Args:\n+            plugin_instance: An instance of a class inheriting from BasePlugin.\n+        \"\"\"\n+        if not isinstance(plugin_instance, BasePlugin):\n+            raise TypeError(f\"Provided object is not an instance of BasePlugin: {type(plugin_instance)}\")\n+        \n+        if plugin_instance.name in self._plugins:\n+            logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n+        \n+        self._plugins[plugin_instance.name] = plugin_instance\n+        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n+\n+    def get_plugin(self, name: str) -> Optional[BasePlugin]:\n+        \"\"\"\n+        Retrieves a registered plugin by its name.\n+        \n+        Args:\n+            name: The name of the plugin to retrieve.\n+\n+        Returns:\n+            The BasePlugin instance if found, otherwise None.\n+        \"\"\"\n+        return self._plugins.get(name)\n+\n+    def get_all_plugins(self) -> Dict[str, BasePlugin]:\n+        \"\"\"\n+        Retrieves a copy of all registered plugins, keyed by their names.\n+        \"\"\"\n+        return self._plugins.copy()\n+\n+    def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n+        \"\"\"\n+        Scans a directory for Python files, attempts to import them as modules,\n+        and registers classes inheriting from `plugin_base_class` as plugins.\n+        \"\"\"\n+        if not plugin_dir.is_dir():\n+            logger.warning(f\"Plugin directory not found or is not a directory: {plugin_dir}\")\n+            return\n+\n+        logger.info(f\"Loading plugins from directory: {plugin_dir}\")\n+        for filepath in plugin_dir.glob(\"*.py\"):\n+            if filepath.name == \"__init__.py\":\n+                continue # Skip __init__.py files\n+\n+            module_name = filepath.stem\n+            try:\n+                spec = importlib.util.spec_from_file_location(module_name, filepath)\n+                if spec and spec.loader:\n+                    module = importlib.util.module_from_spec(spec)\n+                    spec.loader.exec_module(module)\n+\n+                    # Find plugin classes within the module that inherit from the base class\n+                    for attribute_name in dir(module):\n+                        attribute = getattr(module, attribute_name)\n+                        if (isinstance(attribute, type) and \n+                            issubclass(attribute, plugin_base_class) and \n+                            attribute is not plugin_base_class): # Ensure it's not the base class itself\n+                            try:\n+                                plugin_instance = attribute() # Instantiate the plugin\n+                                self.register_plugin(plugin_instance)\n+                                logger.debug(f\"Loaded and registered plugin '{plugin_instance.name}' from '{filepath.name}'.\")\n+                            except Exception as inst_exc:\n+                                logger.error(f\"Failed to instantiate plugin class '{attribute.__name__}' from '{filepath.name}': {inst_exc}\", exc_info=True)\n+                else:\n+                    logger.warning(f\"Could not get module spec or loader for {filepath.name}.\")\n+            except Exception as e:\n+                logger.error(f\"Failed to load module '{filepath.name}' as a plugin: {e}\", exc_info=True)\n+        \n+        logger.info(f\"Finished loading plugins. Total registered: {len(self._plugins)}\")\n+\n+    @property\n+    def registered_plugin_names(self) -> List[str]:\n+        \"\"\"\n+        Returns a list of names of all currently registered plugins.\n+        \"\"\"\n+        return list(self._plugins.keys())\n+\n+    def unregister_plugin(self, name: str) -> bool:\n+        \"\"\"\n+        Unregisters a plugin by its name.\n+        \n+        Args:\n+            name: The name of the plugin to unregister.\n+\n+        Returns:\n+            True if the plugin was unregistered, False otherwise.\n+        \"\"\"\n+        if name in self._plugins:\n+            del self._plugins[name]\n+            logger.info(f\"Plugin '{name}' unregistered.\")\n+            return True\n+        logger.warning(f\"Attempted to unregister non-existent plugin: '{name}'.\")\n+        return False",
  "test_results": {
    "passed": false,
    "error": "pytest not found"
  },
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}