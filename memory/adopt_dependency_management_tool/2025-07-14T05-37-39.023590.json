{
  "cycle": null,
  "goal_id": "adopt_dependency_management_tool",
  "description": "Adopt a dependency management tool (e.g., poetry or pip-tools) to manage dependencies more effectively.",
  "current_code": "",
  "todos": [
    {
      "file_path": "ai_self_ext_engine/core/engine.py",
      "change_type": "modify",
      "description": "Add a new method to the `Engine` class (e.g., `_verify_core_dependencies`) to programmatically check for the presence of critical external packages (like those required by `model_client.py`) and report their status. This enhances the engine's self-awareness regarding its operational requirements.",
      "line_start": 50,
      "line_end": 80
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/engine.py\n+++ b/src/ai_self_ext_engine/core/engine.py\n@@ -1,13 +1,105 @@\n import logging\n+import subprocess\n+import sys\n+import re\n+\n+from ai_self_ext_engine.config.config import Config\n \n logger = logging.getLogger(__name__)\n \n class Engine:\n     def __init__(self):\n         \"\"\"Initializes the Engine with necessary components.\"\"\"\n         # Placeholder for initializing role-specific modules or configurations\n         logger.info(\"Engine initialized.\")\n         self.active_goals = {} # To store goals by ID\n         self.next_goal_id = 1\n+        self._verify_core_dependencies() # Perform dependency check on initialization\n+\n+    def _compare_versions(self, found_version_str: str, expected_version_str: str) -> bool:\n+        \"\"\"\n+        Compares a found version string against an expected version string.\n+        Supports simple '>=X.Y.Z' comparisons by splitting on dots and comparing numerically.\n+        \"\"\"\n+        def parse_version_tuple(version_str):\n+            # Clean up the version string to get just the numbers\n+            match = re.search(r'(\\d+(?:\\.\\d+)*)', version_str)\n+            if match:\n+                return tuple(map(int, match.group(1).split('.')))\n+            return (0,) # Default for unparsable, effectively min version\n+\n+        if not expected_version_str:\n+            return True # No specific version expected, so any found version is fine\n+\n+        # Handle specific tool output formats for cleaning\n+        cleaned_found_version = found_version_str.strip()\n+        if cleaned_found_version.lower().startswith(\"python\"):\n+            cleaned_found_version = cleaned_found_version.split(\" \")[0] # E.g., \"3.9.7 (main, ...)\" -> \"3.9.7\"\n+        elif cleaned_found_version.lower().startswith(\"pip\"):\n+             # E.g., \"pip 21.0.1 from ...\" -> \"21.0.1\"\n+             cleaned_found_version = cleaned_found_version.split(\" \")[1]\n+        elif cleaned_found_version.lower().startswith(\"poetry\"):\n+             # E.g., \"Poetry (version 1.2.3)\" or \"Poetry version 1.2.3\"\n+             match = re.search(r'version\\s+(\\d+(?:\\.\\d+)*)', cleaned_found_version, re.IGNORECASE)\n+             if match:\n+                cleaned_found_version = match.group(1)\n+             else:\n+                cleaned_found_version = cleaned_found_version.split()[-1] # Fallback if regex fails\n+        elif \"version\" in cleaned_found_version.lower():\n+            # Generic case for tools like \"git version X.Y.Z\"\n+            match = re.search(r'version\\s+(\\d+(?:\\.\\d+)*)', cleaned_found_version, re.IGNORECASE)\n+            if match:\n+                cleaned_found_version = match.group(1)\n+            else:\n+                # Just look for any version pattern\n+                match = re.search(r'(\\d+(?:\\.\\d+)*)', cleaned_found_version)\n+                if match:\n+                    cleaned_found_version = match.group(1)\n+\n+        found_parts = parse_version_tuple(cleaned_found_version)\n+\n+        if expected_version_str.startswith(\">=\"):\n+            expected_parts = parse_version_tuple(expected_version_str[2:])\n+            # Pad the shorter tuple with zeros to match length for comparison\n+            max_len = max(len(found_parts), len(expected_parts))\n+            found_parts = found_parts + (0,) * (max_len - len(found_parts))\n+            expected_parts = expected_parts + (0,) * (max_len - len(expected_parts))\n+            return found_parts >= expected_parts\n+        else: # For exact match or if no operator\n+            expected_parts = parse_version_tuple(expected_version_str)\n+            return found_parts == expected_parts\n+\n+    def _verify_core_dependencies(self) -> dict:\n+        \"\"\"\n+        Programmatically checks for the presence and status of critical external packages\n+        and tools required for the engine's operation.\n+        Reports their status based on Config.EXTERNAL_DEPENDENCIES.\n+        \"\"\"\n+        logger.info(\"Verifying core dependencies...\")\n+        dependency_report = {}\n+\n+        for dep in Config.EXTERNAL_DEPENDENCIES:\n+            name = dep[\"name\"]\n+            dep_type = dep[\"type\"]\n+            version_expected = dep.get(\"version_expected\", \"\")\n+            required = dep.get(\"required\", False)\n+\n+            found_status = \"NOT_FOUND\"\n+            found_version = \"N/A\"\n+            is_satisfied = False\n+            details = \"\"\n+\n+            try:\n+                if dep_type == \"tool\":\n+                    # Check if the tool executable exists in PATH\n+                    path_cmd = [\"where\", name] if sys.platform == \"win32\" else [\"which\", name]\n+                    proc_path = subprocess.run(path_cmd, capture_output=True, text=True, check=False, shell=True if sys.platform == \"win32\" else False)\n+\n+                    if proc_path.returncode == 0:\n+                        found_status = \"FOUND\"\n+                        # Try to get the version using '--version' flag, which is common for many tools\n+                        try:\n+                            version_cmd = [name, \"--version\"]\n+                            proc_version = subprocess.run(version_cmd, capture_output=True, text=True, check=False)\n+                            if proc_version.returncode == 0:\n+                                found_version = proc_version.stdout.strip().split('\\n')[0]\n+                                is_satisfied = self._compare_versions(found_version, version_expected)\n+                                details = f\"Found at: {proc_path.stdout.strip().splitlines()[0]}\"\n+                            else:\n+                                details = f\"Found executable at '{proc_path.stdout.strip().splitlines()[0]}', but failed to get version with '{' '.join(version_cmd)}': {proc_version.stderr.strip()}\"\n+                                is_satisfied = False # Can't verify version if we can't get it\n+                        except FileNotFoundError: # Should not happen if proc_path succeeded, but for safety\n+                            details = f\"Found executable at '{proc_path.stdout.strip().splitlines()[0]}', but '{name}' command for version check failed to execute.\"\n+                            is_satisfied = False\n+                        except Exception as e:\n+                            details = f\"Found executable at '{proc_path.stdout.strip().splitlines()[0]}', but error during version check: {e}\"\n+                            is_satisfied = False\n+                    else:\n+                        details = f\"Executable '{name}' not found in PATH.\"\n+\n+                elif dep_type == \"runtime\" and name == \"python\":\n+                    found_version = sys.version.split(\" \")[0] # E.g., \"3.9.7 (main, ...)\" -> \"3.9.7\"\n+                    found_status = \"FOUND\"\n+                    is_satisfied = self._compare_versions(found_version, version_expected)\n+                    details = f\"Running Python version: {found_version}\"\n+\n+                elif dep_type == \"package_manager\":\n+                    cmd = [sys.executable, \"-m\", name, \"--version\"]\n+                    proc = subprocess.run(cmd, capture_output=True, text=True, check=False)\n+                    if proc.returncode == 0:\n+                        found_status = \"FOUND\"\n+                        found_version = proc.stdout.strip().split('\\n')[0]\n+                        is_satisfied = self._compare_versions(found_version, version_expected)\n+                        details = f\"Installed via Python: {found_version}\"\n+                    else:\n+                        details = f\"Command failed or package manager not found: {proc.stderr.strip()}\"\n+                else:\n+                    found_status = \"UNSUPPORTED_TYPE\"\n+                    details = f\"Dependency type '{dep_type}' is not supported for verification.\"\n+\n+            except FileNotFoundError:\n+                found_status = \"NOT_FOUND\"\n+                details = f\"Executable '{name}' not found.\"\n+            except Exception as e:\n+                found_status = \"ERROR_CHECKING\"\n+                details = f\"An error occurred while checking '{name}': {e}\"\n+\n+            report_entry = {\n+                \"name\": name,\n+                \"type\": dep_type,\n+                \"required\": required,\n+                \"version_expected\": version_expected,\n+                \"version_found\": found_version,\n+                \"status\": found_status,\n+                \"is_satisfied\": is_satisfied,\n+                \"details\": details,\n+            }\n+            dependency_report[name] = report_entry\n+\n+            log_level = logger.info\n+            if required and not is_satisfied:\n+                log_level = logger.critical # Use critical for required dependencies not satisfied\n+            elif not is_satisfied:\n+                log_level = logger.warning # Warning for optional dependencies not satisfied\n+            \n+            log_level(f\"Dependency '{name}' ({dep_type}): Status='{found_status}', Version Found='{found_version}', Expected='{version_expected}', Satisfied={is_satisfied}, Required={required}. Details: {details}\")\n+\n+        return dependency_report\n+\n     def problem_identification(self, context: dict) -> dict:\n         \"\"\"Critique phase: identifies problems or areas for improvement.\"\"\"\n         logger.info(\"Executing problem identification (critique) phase.\")\n```",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}