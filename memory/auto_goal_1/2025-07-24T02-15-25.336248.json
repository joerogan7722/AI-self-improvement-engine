{
  "cycle": null,
  "goal_id": "auto_goal_1",
  "description": "Improve refactoring: Found 1 code smells requiring attention",
  "current_code": "# File: src/ai_self_ext_engine/core/engine.py\n            List of instantiated role objects ready for execution\n        \"\"\"\n        loaded_roles: List[Role] = []\n        for role_conf in role_configs:\n            try:\n                module = import_module(role_conf.module)\n                role_class = getattr(module, role_conf.class_name)\n                # Pass learning_log to RefineRole, but not to others\n                if role_conf.class_name == \"RefineRole\":\n                    loaded_roles.append(\n                        role_class(self.config, self.model_client, self.learning_log)\n                    )\n                else:\n                    loaded_roles.append(role_class(self.config, self.model_client))\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading role '%s' from module '%s': %s\",\n                    role_conf.class_name,\n                    role_conf.module,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_roles\n\n    def _load_plugins(\n        self, plugin_configs: Dict[str, PluginConfig]\n    ) -> Dict[str, Plugin]:\n        \"\"\"Dynamically loads plugins based on the plugin_configs.\n        \n        Args:\n            plugin_configs: Dictionary mapping plugin names to their configuration objects\n            \n        Returns:\n            Dictionary mapping plugin names to instantiated plugin objects\n        \"\"\"\n        loaded_plugins: Dict[str, Plugin] = {}\n        for plugin_name, plugin_conf in plugin_configs.items():\n            try:\n                module_path, class_name = plugin_conf.entry_point.rsplit(\".\", 1)\n                module = import_module(module_path)\n                plugin_class = getattr(module, class_name)\n                loaded_plugins[plugin_name] = plugin_class(self.config)\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading plugin '%s' from entry point '%s': %s\",\n                    plugin_name,\n                    plugin_conf.entry_point,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_plugins\n\n    def run_cycles(self):\n        \"\"\"Main loop for the self-improvement process.\n        \n        Enhanced with autonomous goal generation. Continuously processes goals from the goal manager,\n        executing them through configured roles until completion or abort. Automatically generates\n        new goals when the queue is empty.\n        \n        Returns:\n            None: This method runs until all goals are processed or autonomous generation fails\n        \"\"\"\n        self.logger.info(\"Starting self-improvement engine cycles...\")\n\n        while True:\n            goal = self._get_next_goal()\n            if not goal:\n                break\n\n            context = self._setup_goal_context(goal)\n            self._execute_goal_attempts(context)\n\n    def _get_next_goal(self) -> Goal | None:\n        \"\"\"Get the next goal to process, with autonomous generation fallback.\n        \n        Returns:\n            Goal | None: The next goal to process, or None if no goals available and generation failed\n        \"\"\"\n        goal = self.goal_manager.next_goal()\n        if not goal:\n            self.logger.info(\n                \"No pending goals found. Attempting autonomous goal generation...\"\n            )\n            if self._attempt_autonomous_goal_generation():\n                return (\n                    self.goal_manager.next_goal()\n                )  # Try again with newly generated goals\n            else:\n                self.logger.info(\n                    \"No more goals available and auto-generation failed. Exiting.\"\n                )\n                return None\n        return goal\n\n    def _setup_goal_context(self, goal: Goal) -> Context:\n        \"\"\"Set up the context for goal processing, handling snapshot restoration.\n        \n        Args:\n            goal: The goal to set up context for\n            \n        Returns:\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/engine.py",
      "change_type": "modify",
      "description": "Refactor the main execution loop within the engine to decompose large methods into smaller, more focused helper functions, addressing complexity.",
      "line_start": 50,
      "line_end": 150
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/engine.py\n+++ b/src/ai_self_ext_engine/core/engine.py\n@@ -82,9 +82,9 @@\n             Goal | None: The next goal to process, or None if no goals available and generation failed\n         \"\"\"\n         goal = self.goal_manager.next_goal()\n-        if not goal:\n+        if goal is None:\n             self.logger.info(\n                 \"No pending goals found. Attempting autonomous goal generation...\"\n             )\n             if self._attempt_autonomous_goal_generation():\n                 return (\n                     self.goal_manager.next_goal()\n@@ -101,47 +101,67 @@\n         Args:\n             goal: The goal to set up context for\n             \n         Returns:\n-\n+            Context: The initialized context object.\n+        \"\"\"\n+        # The full implementation of _setup_goal_context is not provided,\n+        # but this method would typically initialize and potentially restore context.\n+        # Assuming existing implementation (if any) sets up 'context' variable.\n+        \n+        # Placeholder for actual context setup:\n+        # context = Context(goal=goal, code_dir=self.config.engine.code_dir)\n+        # if self.config.engine.snapshot_restore_enabled and goal.last_snapshot_path:\n+        #     restored_context = self.snapshot_manager.load_snapshot(goal.last_snapshot_path)\n+        #     if restored_context:\n+        #         context = restored_context\n+        #         self.logger.info(\"Restored context from snapshot: %s\", goal.last_snapshot_path)\n+        #     else:\n+        #         self.logger.warning(\"Failed to restore snapshot for goal '%s' at '%s'. Starting fresh.\",\n+        #                             goal.goal_id, goal.last_snapshot_path)\n+        # else:\n+        #     self.logger.info(\"No snapshot to restore for goal '%s' or restore is disabled.\", goal.goal_id)\n+\n+        # Returning a dummy context or existing context based on current code snippet.\n+        # In a real scenario, this would involve proper Context initialization/restoration.\n+        # Since the body is not provided, we just assume it exists and returns Context.\n+        return Context(goal=goal, code_dir=self.config.engine.code_dir) # Example: This line would be part of existing implementation\n+\n+    def _execute_goal_attempts(self, context: Context) -> None:\n+        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\n+\n+        Args:\n+            context: The initial execution context for the goal.\n+        \"\"\"\n+        goal = cast(Goal, context.goal) # Context.goal should not be None at this point based on _get_next_goal check.\n+        for attempt_num in range(1, self.config.engine.max_cycles + 1):\n+            self._log_attempt_start(goal, attempt_num)\n+\n+            self._reset_attempt_state(context)\n+            # _execute_roles now returns the modified context.\n+            context = self._execute_roles(context)\n+            self._record_attempt_results(context, goal)\n+\n+            if self._handle_attempt_outcome(context, goal, attempt_num):\n+                return # Goal completed or aborted, stop further attempts\n+\n+        self._handle_goal_failure(goal)\n+\n+    def _log_attempt_start(self, goal: Goal, attempt_num: int) -> None:\n+        \"\"\"Logs the start of an attempt for a goal.\"\"\"\n+        self.logger.info(\n+            \"Starting attempt %d for goal '%s' (type: %s)\",\n+            attempt_num,\n+            goal.goal_id,\n+            goal.goal_type,\n+        )\n+\n+    def _handle_attempt_outcome(self, context: Context, goal: Goal, attempt_num: int) -> bool:\n+        \"\"\"Handles the outcome of a single goal attempt.\n+        Returns True if the goal is completed or aborted, False otherwise.\n+        \"\"\"\n+        if context.accepted:\n+            self.goal_manager.mark_done(goal.goal_id)\n+            self.logger.info(\"Goal '%s' completed in %s attempts.\", goal.goal_id, attempt_num)\n+            return True\n+        elif context.should_abort:\n+            self.logger.warning(\"Goal '%s' aborted after %s attempts.\", goal.goal_id, attempt_num)\n+            self.goal_manager.mark_failed(goal.goal_id) # Aborted goals are considered failed for tracking\n+            return True\n+        return False\n+\n+    def _handle_goal_failure(self, goal: Goal) -> None:\n+        \"\"\"Marks a goal as failed after max attempts and logs the error.\"\"\"\n+        self.logger.error(\n+            \"Goal '%s' failed to complete after %s attempts.\",\n+            goal.goal_id,\n+            self.config.engine.max_cycles,\n+        )\n+        self.goal_manager.mark_failed(goal.goal_id)\n \n     def _reset_attempt_state(self, context: Context) -> None:\n         \"\"\"Resets the context's accepted and should_abort flags for a new attempt.\"\"\"\n         context.accepted = False\n         context.should_abort = False\n \n-    def _execute_goal_attempts(self, context: Context) -> None:\n-        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n-        for attempt in range(self.config.engine.max_cycles):\n-            goal = cast(Goal, context.goal)  # Ensure goal is not None\n-            self.logger.info(\n-                \"Starting attempt %d for goal '%s' (type: %s)\",\n-                attempt + 1,\n-                goal.goal_id,\n-                goal.goal_type,\n-            )\n-\n-            self._reset_attempt_state(context)\n-            result = self._execute_roles(context)\n-            self._record_attempt_results(context, goal)\n-\n-            if result == \"completed\":\n-                self.goal_manager.mark_done(goal.goal_id)\n-                self.logger.info(\n-                    \"Goal '%s' completed in %s attempts.\",\n-                    goal.goal_id,\n-                    attempt + 1,\n-                )\n-                break\n-            elif result == \"aborted\":\n-                self.logger.warning(\n-                    \"Goal '%s' aborted after %s attempts.\",\n-                    goal.goal_id,\n-                    attempt + 1,\n-                )\n-                self.goal_manager.mark_failed(goal.goal_id)\n-                break\n-        else:\n-            self.logger.error(\n-                \"Goal '%s' failed to complete after %s attempts.\",\n-                goal.goal_id,\n-                self.config.engine.max_cycles,\n-            )\n-            self.goal_manager.mark_failed(goal.goal_id)\n-\n-    def _reset_attempt_state(self, context: Context) -> None:\n-        \"\"\"Resets the context's accepted and should_abort flags for a new attempt.\"\"\"\n-        context.accepted = False\n-        context.should_abort = False\n-\n-    def _execute_roles(self, context: Context) -> str:\n-        \"\"\"Execute all roles and return the result status.\n+    def _execute_roles(self, context: Context) -> Context:\n+        \"\"\"Execute all roles and return the modified context.\n         \n         Args:\n             context: The execution context containing goal and state information\n             \n         Returns:\n-            str: Status string - \"completed\", \"aborted\", or \"continue\"\n+            Context: The modified context after all roles have run, or if an abort was requested.\n         \"\"\"\n         for role in self.roles:\n             self.logger.info(\"Executing role: %s\", role.__class__.__name__)\n             context = role.run(context)\n             if context.should_abort:\n                 self.logger.warning(\n                     \"Role %s requested abort. Stopping attempt.\",\n                     role.__class__.__name__,\n                 )\n-                return \"aborted\"\n-\n-        if context.accepted:\n-            return \"completed\"\n-        return \"continue\"\n+                return context # Return early with the aborted context\n+\n+        return context # Return the final context\n \n     def _record_attempt_results(self, context: Context, goal: Goal) -> None:\n         \"\"\"Record snapshot and learning entry for the attempt.\"\"\"",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}