{
  "cycle": null,
  "goal_id": "auto_goal_1",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/test_utils.py\nimport subprocess\nimport logging\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\n\nlogger = logging.getLogger(__name__)\n\ndef run_tests(\n    project_root: Path,\n    test_path: Path,\n    coverage_report_dir: Optional[Path] = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Runs pytest tests for the specified path within the project root,\n    optionally generating a coverage report.\n\n    Args:\n        project_root: The root directory of the project. Pytest will be run from here.\n                      Coverage will be measured relative to this root.\n        test_path: The path to the tests (file or directory) relative to `project_root`.\n                   e.g., Path(\"tests/unit/test_my_module.py\") or Path(\"tests/\").\n        coverage_report_dir: Optional path to a directory where the coverage XML report\n                             should be saved. If None, no XML report is generated.\n                             The report will be named '.coverage.xml' within this directory.\n\n    Returns:\n        A dictionary containing:\n        - 'success': bool, True if tests passed (return code 0), False otherwise.\n        - 'stdout': str, The standard output from the pytest command.\n        - 'stderr': str, The standard error from the pytest command.\n        - 'coverage_xml_path': Optional[Path], The path to the generated coverage XML report,\n                               if requested and successfully created.\n    \"\"\"\n    results: Dict[str, Any] = {\n        'success': False,\n        'stdout': '',\n        'stderr': '',\n        'coverage_xml_path': None\n    }\n\n    # Ensure pytest is available\n    try:\n        subprocess.run([\"pytest\", \"--version\"], check=True, capture_output=True)\n    except FileNotFoundError:\n        logger.error(\"Pytest is not installed or not in PATH. Please install it (e.g., pip install pytest pytest-cov).\")\n        results['stderr'] = \"Pytest not found.\"\n        return results\n    except subprocess.CalledProcessError as e:\n        logger.error(f\"Error checking pytest version: {e.stderr.decode()}\")\n        results['stderr'] = f\"Error checking pytest version: {e.stderr.decode()}\"\n        return results\n\n    # Construct the pytest command\n    cmd = [\"pytest\"]\n\n    if coverage_report_dir:\n        # Ensure coverage directory exists\n        coverage_report_dir.mkdir(parents=True, exist_ok=True)\n        coverage_xml_path = coverage_report_dir / \".coverage.xml\"\n\n        # Add coverage flags\n        # --cov=. will measure coverage for the entire project from project_root\n        # --cov-report=xml:path/to/.coverage.xml will save the report\n        # --cov-report=term-missing will show missing lines in console\n        cmd.extend([\n            f\"--cov={project_root}\",\n            f\"--cov-report=xml:{coverage_xml_path}\",\n            \"--cov-report=term-missing\"\n        ])\n\n    cmd.append(str(test_path)) # Add the specific test path or directory\n\n    logger.info(f\"Running tests from '{test_path}' with command: {' '.join(cmd)} in directory '{project_root}'\")\n\n    try:\n        process = subprocess.run(cmd, cwd=project_root, capture_output=True, text=True, check=False)\n        results['stdout'] = process.stdout\n        results['stderr'] = process.stderr\n        results['success'] = process.returncode == 0\n        if results['success'] and coverage_report_dir:\n            results['coverage_xml_path'] = coverage_xml_path\n    except Exception as e:\n        logger.exception(f\"An unexpected error occurred while running tests for {test_path}: {e}\")\n        results['stderr'] += f\"\\nAn unexpected error occurred: {e}\"\n\n# AI-generated code improvements:\nimport xml.etree.ElementTree as ET\n        'coverage_xml_path': None,\n        'coverage_data': None  # New key to store parsed coverage metrics\n            # --- Start: Coverage XML Parsing Logic ---\n            if coverage_xml_path.exists():\n                try:\n                    tree = ET.parse(coverage_xml_path)\n                    root = tree.getroot()\n                    coverage_data = {\n                        'overall': {\n                            'line_rate': 0.0,\n                            'lines_covered': 0,\n                            'lines_valid': 0\n                        },\n                        'files': []\n                    }\n                    # Parse overall coverage from <totals> or <coverage> root element\n                    totals_element = root.find('totals')\n                    source_element = totals_element if totals_element is not None else root\n                    coverage_data['overall'] = {\n                        'line_rate': float(source_element.get('line-rate', 0.0)),\n                        'lines_covered': int(source_element.get('lines-covered', 0)),\n                        'lines_valid': int(source_element.get('lines-valid', 0))\n                    }\n                    # Parse per-file coverage\n                    for package_elem in root.findall('packages/package'):\n                        for class_elem in package_elem.findall('classes/class'):\n                            filename = class_elem.get('filename')\n                            if filename:\n                                file_line_rate = float(class_elem.get('line-rate', 0.0))\n                                file_lines_covered = int(class_elem.get('lines-covered', 0))\n                                file_lines_valid = int(class_elem.get('lines-valid', 0))\n                                missing_lines = []\n                                for line_elem in class_elem.findall('lines/line'):\n                                    if line_elem.get('hits') == '0':\n                                        try:\n                                            missing_lines.append(int(line_elem.get('number')))\n                                        except (ValueError, TypeError):\n                                            pass\n                                coverage_data['files'].append({\n                                    'filename': filename,\n                                    'line_rate': file_line_rate,\n                                    'lines_covered': file_lines_covered,\n                                    'lines_valid': file_lines_valid,\n                                    'missing_lines': sorted(missing_lines)\n                                })\n                    results['coverage_data'] = coverage_data\n                    logger.info(f\"Successfully parsed coverage XML from {coverage_xml_path}\")\n                except ET.ParseError as pe:\n                    logger.warning(f\"Failed to parse coverage XML from {coverage_xml_path}: {pe}\")\n                    results['stderr'] += f\"\\nFailed to parse coverage XML: {pe}\"\n                except Exception as parse_e:\n                    logger.warning(f\"An error occurred while processing coverage XML from {coverage_xml_path}: {parse_e}\")\n                    results['stderr'] += f\"\\nError processing coverage XML: {parse_e}\"\n            # --- End: Coverage XML Parsing Logic ---\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/test_utils.py",
      "change_type": "modify",
      "description": "Add a utility function to execute tests with code coverage measurement and return coverage statistics or report path."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/test_utils.py\n+++ b/src/ai_self_ext_engine/test_utils.py\n@@ -2,6 +2,7 @@\n import logging\n from pathlib import Path\n from typing import Optional, Dict, Any\n+import xml.etree.ElementTree as ET\n \n logger = logging.getLogger(__name__)\n \n@@ -29,6 +30,7 @@\n         'stdout': '',\n         'stderr': '',\n         'coverage_xml_path': None\n+        'coverage_data': None  # New key to store parsed coverage metrics\n     }\n \n     # Ensure pytest is available\n@@ -67,8 +69,53 @@\n         results['success'] = process.returncode == 0\n         if results['success'] and coverage_report_dir:\n             results['coverage_xml_path'] = coverage_xml_path\n+            # --- Start: Coverage XML Parsing Logic ---\n+            if coverage_xml_path.exists():\n+                try:\n+                    tree = ET.parse(coverage_xml_path)\n+                    root = tree.getroot()\n+                    coverage_data = {\n+                        'overall': {\n+                            'line_rate': 0.0,\n+                            'lines_covered': 0,\n+                            'lines_valid': 0\n+                        },\n+                        'files': []\n+                    }\n+                    # Parse overall coverage from <totals> or <coverage> root element\n+                    totals_element = root.find('totals')\n+                    source_element = totals_element if totals_element is not None else root\n+                    coverage_data['overall'] = {\n+                        'line_rate': float(source_element.get('line-rate', 0.0)),\n+                        'lines_covered': int(source_element.get('lines-covered', 0)),\n+                        'lines_valid': int(source_element.get('lines-valid', 0))\n+                    }\n+                    # Parse per-file coverage\n+                    for package_elem in root.findall('packages/package'):\n+                        for class_elem in package_elem.findall('classes/class'):\n+                            filename = class_elem.get('filename')\n+                            if filename:\n+                                file_line_rate = float(class_elem.get('line-rate', 0.0))\n+                                file_lines_covered = int(class_elem.get('lines-covered', 0))\n+                                file_lines_valid = int(class_elem.get('lines-valid', 0))\n+                                missing_lines = []\n+                                for line_elem in class_elem.findall('lines/line'):\n+                                    if line_elem.get('hits') == '0':\n+                                        try:\n+                                            missing_lines.append(int(line_elem.get('number')))\n+                                        except (ValueError, TypeError):\n+                                            pass\n+                                coverage_data['files'].append({\n+                                    'filename': filename,\n+                                    'line_rate': file_line_rate,\n+                                    'lines_covered': file_lines_covered,\n+                                    'lines_valid': file_lines_valid,\n+                                    'missing_lines': sorted(missing_lines)\n+                                })\n+                    results['coverage_data'] = coverage_data\n+                    logger.info(f\"Successfully parsed coverage XML from {coverage_xml_path}\")\n+                except ET.ParseError as pe:\n+                    logger.warning(f\"Failed to parse coverage XML from {coverage_xml_path}: {pe}\")\n+                    results['stderr'] += f\"\\nFailed to parse coverage XML: {pe}\"\n+                except Exception as parse_e:\n+                    logger.warning(f\"An error occurred while processing coverage XML from {coverage_xml_path}: {parse_e}\")\n+                    results['stderr'] += f\"\\nError processing coverage XML: {parse_e}\"\n+            # --- End: Coverage XML Parsing Logic ---\n     except Exception as e:\n         logger.exception(f\"An unexpected error occurred while running tests for {test_path}: {e}\")\n         results['stderr'] += f\"\\nAn unexpected error occurred: {e}\"\n-\n-# AI-generated code improvements:\n-import xml.etree.ElementTree as ET\n-        'coverage_xml_path': None,\n-        'coverage_data': None  # New key to store parsed coverage metrics\n-            # --- Start: Coverage XML Parsing Logic ---\n-            if coverage_xml_path.exists():\n-                try:\n-                    tree = ET.parse(coverage_xml_path)\n-                    root = tree.getroot()\n-                    coverage_data = {\n-                        'overall': {\n-                            'line_rate': 0.0,\n-                            'lines_covered': 0,\n-                            'lines_valid': 0\n-                        },\n-                        'files': []\n-                    }\n-                    # Parse overall coverage from <totals> or <coverage> root element\n-                    totals_element = root.find('totals')\n-                    source_element = totals_element if totals_element is not None else root\n-                    coverage_data['overall'] = {\n-                        'line_rate': float(source_element.get('line-rate', 0.0)),\n-                        'lines_covered': int(source_element.get('lines-covered', 0)),\n-                        'lines_valid': int(source_element.get('lines-valid', 0))\n-                    }\n-                    # Parse per-file coverage\n-                    for package_elem in root.findall('packages/package'):\n-                        for class_elem in package_elem.findall('classes/class'):\n-                            filename = class_elem.get('filename')\n-                            if filename:\n-                                file_line_rate = float(class_elem.get('line-rate', 0.0))\n-                                file_lines_covered = int(class_elem.get('lines-covered', 0))\n-                                file_lines_valid = int(class_elem.get('lines-valid', 0))\n-                                missing_lines = []\n-                                for line_elem in class_elem.findall('lines/line'):\n-                                    if line_elem.get('hits') == '0':\n-                                        try:\n-                                            missing_lines.append(int(line_elem.get('number')))\n-                                        except (ValueError, TypeError):\n-                                            pass\n-                                coverage_data['files'].append({\n-                                    'filename': filename,\n-                                    'line_rate': file_line_rate,\n-                                    'lines_covered': file_lines_covered,\n-                                    'lines_valid': file_lines_valid,\n-                                    'missing_lines': sorted(missing_lines)\n-                                })\n-                    results['coverage_data'] = coverage_data\n-                    logger.info(f\"Successfully parsed coverage XML from {coverage_xml_path}\")\n-                except ET.ParseError as pe:\n-                    logger.warning(f\"Failed to parse coverage XML from {coverage_xml_path}: {pe}\")\n-                    results['stderr'] += f\"\\nFailed to parse coverage XML: {pe}\"\n-                except Exception as parse_e:\n-                    logger.warning(f\"An error occurred while processing coverage XML from {coverage_xml_path}: {parse_e}\")\n-                    results['stderr'] += f\"\\nError processing coverage XML: {parse_e}\"\n-            # --- End: Coverage XML Parsing Logic ---",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}