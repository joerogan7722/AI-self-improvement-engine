{
  "cycle": null,
  "goal_id": "auto_goal_1",
  "description": "Improve refactoring: Found 1 code smells requiring attention",
  "current_code": "# File: src/ai_self_ext_engine/core/engine.py\nfrom typing import List, Dict, cast\nfrom importlib import import_module\nfrom pathlib import Path\nimport logging\n\nfrom .role import Context, Role\nfrom .plugin import Plugin\nfrom ..config import MainConfig, RoleConfig, PluginConfig\nfrom ..goal_manager import GoalManager, Goal\nfrom ..snapshot_store import SnapshotStore\nfrom ..model_client import ModelClient\nfrom ..learning_log import LearningLog, create_learning_entry\n\n\nclass Engine:\n    \"\"\"\n    Orchestrates the self-improvement process, managing cycles,\n    goals, roles, and snapshots.\n    \"\"\"\n\n    logger = logging.getLogger(__name__)\n\n    def __init__(self, config: MainConfig):\n        \"\"\"Initialize the Engine with configuration.\n        \n        Args:\n            config: Main configuration object containing engine settings, paths, and model configuration\n        \"\"\"\n        self.config = config\n        self.goal_manager = GoalManager(self.config.engine.goals_path)\n        self.snapshot_store = SnapshotStore(self.config.engine.memory_path)\n        self.model_client = ModelClient(self.config.model)\n        self.learning_log = LearningLog(\n            Path(self.config.engine.memory_path) / \"learning\"\n        )\n\n        # Ensure core directories exist for the project structure\n        Path(self.config.engine.code_dir).mkdir(parents=True, exist_ok=True)\n\n        self.roles = self._load_roles(config.roles)\n        self.plugins = self._load_plugins(config.plugins)\n\n    def _load_roles(self, role_configs: List[RoleConfig]) -> List[Role]:\n        \"\"\"Dynamically loads and instantiates roles based on the role_configs.\n        \n        Args:\n            role_configs: List of role configuration objects specifying modules and classes to load\n            \n        Returns:\n            List of instantiated role objects ready for execution\n        \"\"\"\n        loaded_roles: List[Role] = []\n        for role_conf in role_configs:\n            try:\n                module = import_module(role_conf.module)\n                role_class = getattr(module, role_conf.class_name)\n                # Pass learning_log to RefineRole, but not to others\n                if role_conf.class_name == \"RefineRole\":\n                    loaded_roles.append(\n                        role_class(self.config, self.model_client, self.learning_log)\n                    )\n                else:\n                    loaded_roles.append(role_class(self.config, self.model_client))\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading role '%s' from module '%s': %s\",\n                    role_conf.class_name,\n                    role_conf.module,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_roles\n\n    def _load_plugins(\n        self, plugin_configs: Dict[str, PluginConfig]\n    ) -> Dict[str, Plugin]:\n        \"\"\"Dynamically loads plugins based on the plugin_configs.\n        \n        Args:\n            plugin_configs: Dictionary mapping plugin names to their configuration objects\n            \n        Returns:\n            Dictionary mapping plugin names to instantiated plugin objects\n        \"\"\"\n        loaded_plugins: Dict[str, Plugin] = {}\n        for plugin_name, plugin_conf in plugin_configs.items():\n            try:\n                module_path, class_name = plugin_conf.entry_point.rsplit(\".\", 1)\n                module = import_module(module_path)\n                plugin_class = getattr(module, class_name)\n                loaded_plugins[plugin_name] = plugin_class(self.config)\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading plugin '%s' from entry point '%s': %s\",\n                    plugin_name,\n                    plugin_conf.entry_point,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_plugins\n\n    def run_cycles(self):\n        \"\"\"Main loop for the self-improvement process.\n        \n        Enhanced with autonomous goal generation. Continuously processes goals from the goal manager,\n        executing them through configured roles until completion or abort. Automatically generates\n        new goals when the queue is empty.\n        \n        Returns:\n            None: This method runs until all goals are processed or autonomous generation fails\n        \"\"\"\n        self.logger.info(\"Starting self-improvement engine cycles...\")\n\n        while True:\n            goal = self._get_next_goal()\n            if not goal:\n                break\n\n            context = self._setup_goal_context(goal)\n            self._execute_goal_attempts(context)\n\n    def _get_next_goal(self) -> Goal | None:\n        \"\"\"Get the next goal to process, with autonomous generation fallback.\n        \n        Returns:\n            Goal | None: The next goal to process, or None if no goals available and generation failed\n        \"\"\"\n        goal = self.goal_manager.next_goal()\n        if not goal:\n            self.logger.info(\n                \"No pending goals found. Attempting autonomous goal generation...\"\n            )\n            if self._attempt_autonomous_goal_generation():\n                return (\n                    self.goal_manager.next_goal()\n                )  # Try again with newly generated goals\n            else:\n                self.logger.info(\n                    \"No more goals available and auto-generation failed. Exiting.\"\n                )\n                return None\n        return goal\n\n    def _setup_goal_context(self, goal: Goal) -> Context:\n        \"\"\"Set up the context for goal processing, handling snapshot restoration.\n        \n        Args:\n            goal: The goal to set up context for\n            \n        Returns:\n            Context: Configured context object ready for goal processing\n        \"\"\"\n        context = Context(code_dir=self.config.engine.code_dir, goal=goal)\n        goal = cast(Goal, context.goal)  # Ensure goal is correctly typed\n\n        self.logger.info(\n            \"\\n--- Processing Goal: %s - %s ---\",\n            goal.goal_id,\n            goal.description,\n        )\n\n        loaded_snapshot = self.snapshot_store.load_latest(goal.goal_id)\n        if loaded_snapshot:\n            loaded_snapshot.goal = goal\n            context = loaded_snapshot\n            self.logger.info(\n                \"Resuming goal '%s' from previous snapshot.\",\n                goal.goal_id,\n            )\n        else:\n            self.logger.info(\n                \"Starting new attempt for goal '%s'.\",\n                goal.goal_id,\n            )\n            context.todos = []\n\n        return context\n\n    def _execute_goal_attempts(self, context: Context) -> None:\n        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n        for attempt in range(self.config.engine.max_cycles):\n            goal = cast(Goal, context.goal)  # Ensure goal is not None\n            self.logger.info(\n                \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                goal.goal_id,\n                attempt + 1,\n                self.config.engine.max_cycles,\n            )\n\n            self._reset_attempt_state(context)\n            result = self._execute_roles(context)\n            self._record_attempt_results(context, goal)\n\n            if result == \"completed\":\n                self.goal_manager.mark_done(goal.goal_id)\n                self.logger.info(\n                    \"Goal '%s' completed in %s attempts.\",\n                    goal.goal_id,\n                    attempt + 1,\n                )\n                break\n            elif result == \"aborted\":\n                self.logger.warning(\n                    \"Goal '%s' aborted after %s attempts.\",\n                    goal.goal_id,\n                    attempt + 1,\n                )\n                break  # Move to the next pending goal\n\n    def _reset_attempt_state(self, context: Context) -> None:\n        \"\"\"Reset transient state for a new attempt.\"\"\"\n        context.patch = None\n        context.test_results = None\n        context.review = None\n        context.accepted = False\n        context.should_abort = False\n\n    def _execute_roles(self, context: Context) -> str:\n        \"\"\"Execute all roles and return the result status.\n        \n        Args:\n            context: The execution context containing goal and state information\n            \n        Returns:\n            str: Status string - \"completed\", \"aborted\", or \"continue\"\n        \"\"\"\n        for role in self.roles:\n            self.logger.info(\"Executing role: %s\", role.__class__.__name__)\n            context = role.run(context)\n            if context.should_abort:\n                self.logger.warning(\n                    \"Role %s requested abort. Stopping attempt.\",\n                    role.__class__.__name__,\n                )\n                return \"aborted\"\n\n        if context.accepted:\n            return \"completed\"\n        return \"continue\"\n\n    def _record_attempt_results(self, context: Context, goal: Goal) -> None:\n        \"\"\"Record snapshot and learning entry for the attempt.\"\"\"\n        self.snapshot_store.record(context)\n\n        # Record learning entry\n        learning_entry = create_learning_entry(\n            goal=goal.description,\n            patch=context.patch or \"\",\n            test_results=context.test_results or {},\n            review=context.review or \"\",\n            success=context.accepted,\n        )\n        self.learning_log.record_entry(learning_entry)\n\n    def _attempt_autonomous_goal_generation(self) -> bool:\n        \"\"\"\n        Attempts to autonomously generate new goals when none are available.\n        Returns True if goals were successfully generated and added.\n        \"\"\"\n        try:\n            self.logger.info(\"Initiating autonomous goal generation...\")\n\n            # Try to load the GoalGenerationRole\n            from ai_self_ext_engine.roles.goal_generation import GoalGenerationRole\n\n            goal_generator = GoalGenerationRole(self.config, self.model_client)\n\n            # Create context for goal generation\n            context = Context(code_dir=self.config.engine.code_dir)\n\n            # Run goal generation\n            context = goal_generator.run(context)\n\n            # Extract generated goals from metadata\n            if \"generated_goals\" in context.metadata:\n                generated_goals = context.metadata[\"generated_goals\"]\n\n                self.logger.info(f\"Generated {len(generated_goals)} autonomous goals\")\n\n                # Add goals to goal manager\n                goals_added = 0\n                for goal_data in generated_goals:\n                    try:\n                        from ai_self_ext_engine.goal_manager import Goal\n\n                        goal = Goal(\n                            goal_id=goal_data[\"id\"],\n                            description=goal_data[\"description\"],\n                            priority=goal_data.get(\"priority\", \"medium\"),\n                            metadata=goal_data.get(\"metadata\", {}),\n                        )\n                        self.goal_manager.add_goal(goal)\n                        goals_added += 1\n                        self.logger.info(f\"Added autonomous goal: {goal.description}\")\n                    except Exception as e:\n                        self.logger.error(f\"Failed to add generated goal: {e}\")\n\n                return goals_added > 0\n            else:\n                self.logger.warning(\n                    \"Goal generation completed but no goals were produced\"\n                )\n                return False\n\n        except ImportError as e:\n            self.logger.error(f\"GoalGenerationRole not available: {e}\")\n            return False\n        except Exception as e:\n            self.logger.error(f\"Autonomous goal generation failed: {e}\")\n            return False\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/engine.py",
      "change_type": "modify",
      "description": "Refactor the main execution method within the Engine class (e.g., 'run' or a similar orchestrator method) by extracting distinct functional blocks into smaller, private helper methods to reduce complexity and improve readability."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/engine.py\n+++ b/src/ai_self_ext_engine/core/engine.py\n@@ -165,8 +165,7 @@\n \n     def _execute_goal_attempts(self, context: Context) -> None:\n         \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n-        for attempt in range(self.config.engine.max_cycles):\n-            goal = cast(Goal, context.goal)  # Ensure goal is not None\n+        goal = cast(Goal, context.goal) # Ensure goal is not None\n             self.logger.info(\n                 \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                 goal.goal_id,\n@@ -177,21 +176,9 @@\n             self._reset_attempt_state(context)\n             result = self._execute_roles(context)\n             self._record_attempt_results(context, goal)\n-\n-            if result == \"completed\":\n-                self.goal_manager.mark_done(goal.goal_id)\n-                self.logger.info(\n-                    \"Goal '%s' completed in %s attempts.\",\n-                    goal.goal_id,\n-                    attempt + 1,\n-                )\n-                break\n-            elif result == \"aborted\":\n-                self.logger.warning(\n-                    \"Goal '%s' aborted after %s attempts.\",\n-                    goal.goal_id,\n-                    attempt + 1,\n-                )\n+            \n+            if self._handle_attempt_outcome(goal, result, attempt):\n                 break  # Move to the next pending goal\n \n     def _reset_attempt_state(self, context: Context) -> None:\n@@ -231,3 +218,21 @@\n         )\n         self.learning_log.record_entry(learning_entry)\n \n+    def _handle_attempt_outcome(self, goal: Goal, result: str, attempt: int) -> bool:\n+        \"\"\"\n+        Handles the outcome of a single goal attempt, logging and marking goal status.\n+        Returns True if the goal processing loop should terminate (completed/aborted), False otherwise.\n+        \"\"\"\n+        if result == \"completed\":\n+            self.goal_manager.mark_done(goal.goal_id)\n+            self.logger.info(\n+                \"Goal '%s' completed in %s attempts.\",\n+                goal.goal_id,\n+                attempt + 1,\n+            )\n+            return True\n+        elif result == \"aborted\":\n+            self.logger.warning(\n+                \"Goal '%s' aborted after %s attempts.\",\n+                goal.goal_id,\n+                attempt + 1,\n+            )\n+            return True\n+        return False",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}