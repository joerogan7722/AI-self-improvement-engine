{
  "cycle": null,
  "goal_id": "auto_goal_1",
  "description": "Improve refactoring: Found 1 code smells requiring attention",
  "current_code": "# File: src/ai_self_ext_engine/core/engine.py\n            List of instantiated role objects ready for execution\n        \"\"\"\n        loaded_roles: List[Role] = []\n        for role_conf in role_configs:\n            try:\n                module = import_module(role_conf.module)\n                role_class = getattr(module, role_conf.class_name)\n                # Pass learning_log to RefineRole, but not to others\n                if role_conf.class_name == \"RefineRole\":\n                    loaded_roles.append(\n                        role_class(self.config, self.model_client, self.learning_log)\n                    )\n                else:\n                    loaded_roles.append(role_class(self.config, self.model_client))\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading role '%s' from module '%s': %s\",\n                    role_conf.class_name,\n                    role_conf.module,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_roles\n\n    def _load_plugins(\n        self, plugin_configs: Dict[str, PluginConfig]\n    ) -> Dict[str, Plugin]:\n        \"\"\"Dynamically loads plugins based on the plugin_configs.\n        \n        Args:\n            plugin_configs: Dictionary mapping plugin names to their configuration objects\n            \n        Returns:\n            Dictionary mapping plugin names to instantiated plugin objects\n        \"\"\"\n        loaded_plugins: Dict[str, Plugin] = {}\n        for plugin_name, plugin_conf in plugin_configs.items():\n            try:\n                module_path, class_name = plugin_conf.entry_point.rsplit(\".\", 1)\n                module = import_module(module_path)\n                plugin_class = getattr(module, class_name)\n                loaded_plugins[plugin_name] = plugin_class(self.config)\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading plugin '%s' from entry point '%s': %s\",\n                    plugin_name,\n                    plugin_conf.entry_point,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_plugins\n\n    def run_cycles(self):\n        \"\"\"Main loop for the self-improvement process.\n        \n        Enhanced with autonomous goal generation. Continuously processes goals from the goal manager,\n        executing them through configured roles until completion or abort. Automatically generates\n        new goals when the queue is empty.\n        \n        Returns:\n            None: This method runs until all goals are processed or autonomous generation fails\n        \"\"\"\n        self.logger.info(\"Starting self-improvement engine cycles...\")\n\n        while True:\n            goal = self._get_next_goal()\n            if not goal:\n                break\n\n            context = self._setup_goal_context(goal)\n            self._execute_goal_attempts(context)\n\n    def _get_next_goal(self) -> Goal | None:\n        \"\"\"Get the next goal to process, with autonomous generation fallback.\n        \n        Returns:\n            Goal | None: The next goal to process, or None if no goals available and generation failed\n        \"\"\"\n        goal = self.goal_manager.next_goal()\n        if not goal:\n            self.logger.info(\n                \"No pending goals found. Attempting autonomous goal generation...\"\n            )\n            if self._attempt_autonomous_goal_generation():\n                return (\n                    self.goal_manager.next_goal()\n                )  # Try again with newly generated goals\n            else:\n                self.logger.info(\n                    \"No more goals available and auto-generation failed. Exiting.\"\n                )\n                return None\n        return goal\n\n    def _setup_goal_context(self, goal: Goal) -> Context:\n        \"\"\"Set up the context for goal processing, handling snapshot restoration.\n        \n        Args:\n            goal: The goal to set up context for\n            \n        Returns:\n            Context: Configured context object ready for goal processing\n        \"\"\"\n        context = Context(code_dir=self.config.engine.code_dir, goal=goal)\n        goal = cast(Goal, context.goal)  # Ensure goal is correctly typed\n\n        self.logger.info(\n            \"\\n--- Processing Goal: %s - %s ---\",\n            goal.goal_id,\n            goal.description,\n        )\n\n        loaded_snapshot = self.snapshot_store.load_latest(goal.goal_id)\n        if loaded_snapshot:\n            loaded_snapshot.goal = goal\n            context = loaded_snapshot\n            self.logger.info(\n                \"Resuming goal '%s' from previous snapshot.\",\n                goal.goal_id,\n            )\n        else:\n            self.logger.info(\n                \"Starting new attempt for goal '%s'.\",\n                goal.goal_id,\n            )\n            context.todos = []\n\n        return context\n\n    def _execute_goal_attempts(self, context: Context) -> None:\n        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n        for attempt in range(self.config.engine.max_cycles):\n            goal = cast(Goal, context.goal)  # Ensure goal is not None\n            self.logger.info(\n                \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                goal.goal_id,\n                attempt + 1,\n                self.config.engine.max_cycles,\n            )\n\n            self._reset_attempt_state(context)\n            result = self._execute_roles(context)\n            self._record_attempt_results(context, goal)\n\n            if result == \"completed\":\n                self.goal_manager.mark_done(goal.goal_id)\n                self.logger.info(\n                    \"Goal '%s' completed in %s attempts.\",\n                    goal.goal_id,\n                    attempt + 1,\n                )\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/engine.py",
      "change_type": "modify",
      "description": "Refactor the core execution loop to break down complex methods and improve overall code readability and maintainability, addressing identified code smells.",
      "line_start": 50,
      "line_end": 200
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/engine.py\n+++ b/src/ai_self_ext_engine/core/engine.py\n@@ -176,19 +176,7 @@\n             self.logger.info(\n                 \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                 goal.goal_id,\n                 attempt + 1,\n                 self.config.engine.max_cycles,\n             )\n-\n             self._reset_attempt_state(context)\n             result = self._execute_roles(context)\n             self._record_attempt_results(context, goal)\n-\n-            if result == \"completed\":\n-                self.goal_manager.mark_done(goal.goal_id)\n-                self.logger.info(\n-                    \"Goal '%s' completed in %s attempts.\",\n-                    goal.goal_id,\n-                    attempt + 1,\n-                )\n+            if self._handle_attempt_outcome(goal, result, attempt):\n+                break\n \n     def _reset_attempt_state(self, context: Context) -> None:\n         \"\"\"Reset transient state for a new attempt.\"\"\"\n@@ -234,6 +222,24 @@\n         )\n         self.learning_log.record_entry(learning_entry)\n \n+    def _handle_attempt_outcome(self, goal: Goal, result: str, attempt: int) -> bool:\n+        \"\"\"\n+        Handles the outcome of a single goal attempt, logging and marking goal status.\n+        Returns True if the goal processing loop should terminate (completed/aborted), False otherwise.\n+        \"\"\"\n+        if result == \"completed\":\n+            self.goal_manager.mark_done(goal.goal_id)\n+            self.logger.info(\n+                \"Goal '%s' completed in %s attempts.\",\n+                goal.goal_id,\n+                attempt + 1,\n+            )\n+            return True\n+        elif result == \"aborted\":\n+            self.logger.warning(\n+                \"Goal '%s' aborted after %s attempts.\",\n+                goal.goal_id,\n+                attempt + 1,\n+            )\n+            return True\n+        return False\n+\n     def _attempt_autonomous_goal_generation(self) -> bool:\n         \"\"\"\n         Attempts to autonomously generate new goals when none are available.",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}