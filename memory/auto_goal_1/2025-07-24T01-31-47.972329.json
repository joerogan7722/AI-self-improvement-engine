{
  "cycle": null,
  "goal_id": "auto_goal_1",
  "description": "Improve refactoring: Found 1 code smells requiring attention",
  "current_code": "# File: src/ai_self_ext_engine/core/engine.py\n            List of instantiated role objects ready for execution\n        \"\"\"\n        loaded_roles: List[Role] = []\n        for role_conf in role_configs:\n            try:\n                module = import_module(role_conf.module)\n                role_class = getattr(module, role_conf.class_name)\n                # Pass learning_log to RefineRole, but not to others\n                if role_conf.class_name == \"RefineRole\":\n                    loaded_roles.append(\n                        role_class(self.config, self.model_client, self.learning_log)\n                    )\n                else:\n                    loaded_roles.append(role_class(self.config, self.model_client))\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading role '%s' from module '%s': %s\",\n                    role_conf.class_name,\n                    role_conf.module,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_roles\n\n    def _load_plugins(\n        self, plugin_configs: Dict[str, PluginConfig]\n    ) -> Dict[str, Plugin]:\n        \"\"\"Dynamically loads plugins based on the plugin_configs.\n        \n        Args:\n            plugin_configs: Dictionary mapping plugin names to their configuration objects\n            \n        Returns:\n            Dictionary mapping plugin names to instantiated plugin objects\n        \"\"\"\n        loaded_plugins: Dict[str, Plugin] = {}\n        for plugin_name, plugin_conf in plugin_configs.items():\n            try:\n                module_path, class_name = plugin_conf.entry_point.rsplit(\".\", 1)\n                module = import_module(module_path)\n                plugin_class = getattr(module, class_name)\n                loaded_plugins[plugin_name] = plugin_class(self.config)\n            except (ImportError, AttributeError, TypeError) as e:\n                self.logger.exception(\n                    \"Error loading plugin '%s' from entry point '%s': %s\",\n                    plugin_name,\n                    plugin_conf.entry_point,\n                    e,\n                )\n                raise  # Re-raise to stop execution\n        return loaded_plugins\n\n    def run_cycles(self):\n        \"\"\"Main loop for the self-improvement process.\n        \n        Enhanced with autonomous goal generation. Continuously processes goals from the goal manager,\n        executing them through configured roles until completion or abort. Automatically generates\n        new goals when the queue is empty.\n        \n        Returns:\n            None: This method runs until all goals are processed or autonomous generation fails\n        \"\"\"\n        self.logger.info(\"Starting self-improvement engine cycles...\")\n\n        while True:\n            goal = self._get_next_goal()\n            if not goal:\n                break\n\n            context = self._setup_goal_context(goal)\n            self._execute_goal_attempts(context)\n\n    def _get_next_goal(self) -> Goal | None:\n        \"\"\"Get the next goal to process, with autonomous generation fallback.\n        \n        Returns:\n            Goal | None: The next goal to process, or None if no goals available and generation failed\n        \"\"\"\n        goal = self.goal_manager.next_goal()\n        if not goal:\n            self.logger.info(\n                \"No pending goals found. Attempting autonomous goal generation...\"\n            )\n            if self._attempt_autonomous_goal_generation():\n                return (\n                    self.goal_manager.next_goal()\n                )  # Try again with newly generated goals\n            else:\n                self.logger.info(\n                    \"No more goals available and auto-generation failed. Exiting.\"\n                )\n                return None\n        return goal\n\n    def _setup_goal_context(self, goal: Goal) -> Context:\n        \"\"\"Set up the context for goal processing, handling snapshot restoration.\n        \n        Args:\n            goal: The goal to set up context for\n            \n        Returns:\n            Context: Configured context object ready for goal processing\n        \"\"\"\n        context = Context(code_dir=self.config.engine.code_dir, goal=goal)\n        goal = cast(Goal, context.goal)  # Ensure goal is correctly typed\n\n        self.logger.info(\n            \"\\n--- Processing Goal: %s - %s ---\",\n            goal.goal_id,\n            goal.description,\n        )\n\n        loaded_snapshot = self.snapshot_store.load_latest(goal.goal_id)\n        if loaded_snapshot:\n            loaded_snapshot.goal = goal\n            context = loaded_snapshot\n            self.logger.info(\n                \"Resuming goal '%s' from previous snapshot.\",\n                goal.goal_id,\n            )\n        else:\n            self.logger.info(\n                \"Starting new attempt for goal '%s'.\",\n                goal.goal_id,\n            )\n            context.todos = []\n\n        return context\n\n    def _execute_goal_attempts(self, context: Context) -> None:\n        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n        for attempt in range(self.config.engine.max_cycles):\n            goal = cast(Goal, context.goal)  # Ensure goal is not None\n            self.logger.info(\n                \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                goal.goal_id,\n                attempt + 1,\n                self.config.engine.max_cycles,\n            )\n\n            self._reset_attempt_state(context)\n            result = self._execute_roles(context)\n            self._record_attempt_results(context, goal)\n\n            if result == \"completed\":\n                self.goal_manager.mark_done(goal.goal_id)\n                self.logger.info(\n                    \"Goal '%s' completed in %s attempts.\",\n                    goal.goal_id,\n                    attempt + 1,\n                )\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/engine.py",
      "change_type": "modify",
      "description": "Refactor the main execution loop or core decision-making logic within the Engine class to reduce complexity and improve modularity.",
      "line_start": 50,
      "line_end": 200
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/engine.py\n+++ b/src/ai_self_ext_engine/core/engine.py\n@@ -1,13 +1,38 @@\n-            List of instantiated role objects ready for execution\n+import asyncio # Required for async execution\n+from importlib import import_module\n+import logging\n+from typing import List, Dict, cast, Any, Callable, Coroutine, Optional\n+\n+# Assuming other necessary imports like MainConfig, LLMClient, Goal, Role, RoleConfig, Plugin, PluginConfig, Context, SnapshotStore, GoalManager are already present\n+from ..core.role_orchestrator import RoleOrchestrator, AdaptiveRole # New: Import RoleOrchestrator and AdaptiveRole\n+from ..core.context import Context # New: Import Context for AdaptiveRole type hint if not already imported\n+from ..config import MainConfig # Ensure MainConfig is imported for __init__ type hint\n+from ..utils.llm_client import LLMClient # Ensure LLMClient is imported for __init__ type hint\n+from ..core.goals import Goal # Ensure Goal is imported for method type hints\n+from ..core.base_role import Role, RoleConfig # Ensure Role and RoleConfig are imported for method type hints\n+\n+# Set up a logger for the module (assuming this is at the top level of the file)\n+logger = logging.getLogger(__name__)\n+\n+# Assuming the Engine class definition exists here\n+class Engine:\n+    # Assuming __init__ method is present and its content is similar to this simplified version\n+    def __init__(self, config: MainConfig, model_client: LLMClient):\n+        self.config = config\n+        self.model_client = model_client\n+        self.logger = logging.getLogger(self.__class__.__name__)\n+        self.learning_log: List[Dict[str, Any]] = []\n+\n+        # Assume these are initialized elsewhere in __init__\n+        # self.snapshot_store = SnapshotStore(config)\n+        # self.goal_manager = GoalManager(config)\n+\n+        # Initialize the RoleOrchestrator\n+        self.role_orchestrator = RoleOrchestrator()\n+\n+        # Assume _load_roles and _load_plugins are called here\n+        # self.roles = self._load_roles(self.config.roles)\n+        # self.plugins = self._load_plugins(self.config.plugins)\n+\n+    def _load_roles(self, role_configs: List[RoleConfig]) -> List[Role]:\n+        \"\"\"Dynamically loads roles based on the role_configs.\n+        It also registers these roles with the internal RoleOrchestrator.\n         \"\"\"\n         loaded_roles: List[Role] = []\n         for role_conf in role_configs:\n             try:\n                 module = import_module(role_conf.module)\n                 role_class = getattr(module, role_conf.class_name)\n                 # Pass learning_log to RefineRole, but not to others\n                 if role_conf.class_name == \"RefineRole\":\n-                    loaded_roles.append(\n-                        role_class(self.config, self.model_client, self.learning_log)\n-                    )\n+                    # Use assignment expression to capture the instance before appending\n+                    role_instance = role_class(self.config, self.model_client, self.learning_log)\n                 else:\n-                    loaded_roles.append(role_class(self.config, self.model_client))\n+                    # Use assignment expression to capture the instance before appending\n+                    role_instance = role_class(self.config, self.model_client)\n+                \n+                loaded_roles.append(role_instance)\n+\n+                # Register the role with the orchestrator as an AdaptiveRole\n+                # Assume role_instance.run is an awaitable (async) method\n+                adaptive_role = AdaptiveRole(\n+                    name=role_conf.class_name, # Use class name as the unique name for the role\n+                    description=f\"AI agent role: {role_conf.class_name}\", # Provide a generic description\n+                    run=role_instance.run, # Link the async run method of the actual role instance\n+                    config=role_instance.config if hasattr(role_instance, 'config') else self.config # Pass role's specific config or fallback to main engine config\n+                )\n+                self.role_orchestrator.register_role(adaptive_role)\n             except (ImportError, AttributeError, TypeError) as e:\n                 self.logger.exception(\n                     \"Error loading role '%s' from module '%s': %s\",\n@@ -46,7 +71,7 @@\n                 raise  # Re-raise to stop execution\n         return loaded_plugins\n \n-    def run_cycles(self):\n+    async def run_cycles(self): # Make run_cycles asynchronous\n         \"\"\"Main loop for the self-improvement process.\n         \n         Enhanced with autonomous goal generation. Continuously processes goals from the goal manager,\n         executing them through configured roles until completion or abort. Automatically generates\n         new goals when the queue is empty.\n         \n@@ -62,7 +87,7 @@\n                 break\n \n             context = self._setup_goal_context(goal)\n-            self._execute_goal_attempts(context)\n+            await self._execute_goal_attempts(context) # Await the async method\n \n     def _get_next_goal(self) -> Goal | None:\n         \"\"\"Get the next goal to process, with autonomous generation fallback.\n@@ -115,10 +140,25 @@\n \n         return context\n \n-    def _execute_goal_attempts(self, context: Context) -> None:\n-        \"\"\"Execute multiple attempts for a goal until completion or max cycles reached.\"\"\"\n+    async def _execute_goal_attempts(self, context: Context) -> None: # Make async\n+        \"\"\"\n+        Execute multiple attempts for a goal until completion or max cycles reached.\n+        Delegates role execution to the RoleOrchestrator.\n+        \"\"\"\n         for attempt in range(self.config.engine.max_cycles):\n             goal = cast(Goal, context.goal)  # Ensure goal is not None\n             self.logger.info(\n                 \"\\n--- Goal '%s' Attempt %s/%s ---\",\n                 goal.goal_id,\n                 attempt + 1,\n                 self.config.engine.max_cycles,\n             )\n \n             self._reset_attempt_state(context)\n-            result = self._execute_roles(context)\n-            self._record_attempt_results(context, goal)\n-\n-            if result == \"completed\":\n+            \n+            # Replace direct role execution with RoleOrchestrator's adaptive workflow\n+            # The orchestrator returns the modified context after its execution\n+            updated_context_from_orchestrator = await self.role_orchestrator.execute_adaptive_workflow(\n+                context,\n+                goal_hint=goal.goal_type if hasattr(goal, 'goal_type') else None # Pass goal_type as a hint if available\n+            )\n+            \n+            # Record results based on the context returned by the orchestrator\n+            self._record_attempt_results(updated_context_from_orchestrator, goal)\n+\n+            # Check for completion or abort signals from the orchestrator's output context\n+            if updated_context_from_orchestrator.accepted: # Assuming Context has an 'accepted' flag indicating goal completion\n                 self.goal_manager.mark_done(goal.goal_id)\n                 self.logger.info(\n                     \"Goal '%s' completed in %s attempts.\",\n                     goal.goal_id,\n                     attempt + 1,\n                 )\n+                break # Goal completed, exit the attempt loop\n+            elif updated_context_from_orchestrator.should_abort: # Assuming Context has a 'should_abort' flag for critical errors\n+                 self.logger.warning(f\"Goal '{goal.goal_id}' aborted due to critical error after {attempt + 1} attempts.\")\n+                 # Assuming GoalManager has a mark_failed method to record this state\n+                 self.goal_manager.mark_failed(goal.goal_id) \n+                 break # Abort, exit the attempt loop\n+            else:\n+                self.logger.info(\n+                    \"Goal '%s' not yet completed after attempt %s. Continuing.\",\n+                    goal.goal_id,\n+                    attempt + 1,\n+                )\n+                # If all attempts exhausted without completion\n+                if attempt == self.config.engine.max_cycles - 1:\n+                    self.logger.error(f\"Goal '{goal.goal_id}' failed to complete after {self.config.engine.max_cycles} attempts.\")\n+                    # Assuming GoalManager has a mark_failed method to record this state\n+                    self.goal_manager.mark_failed(goal.goal_id)",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}