{
  "cycle": null,
  "goal_id": "auto_goal_2",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/roles/test.py\nimport subprocess\nimport os\nimport logging\nfrom pathlib import Path\nfrom ai_self_ext_engine.core.role import Role, Context\nfrom ai_self_ext_engine.config import MainConfig\nfrom ai_self_ext_engine.model_client import ModelClient, ModelCallError\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass TestRole(Role):\n    \"\"\"\n    Role responsible for generating and running tests on the codebase.\n    \"\"\"\n\n    def __init__(self, config: MainConfig, model_client: ModelClient):\n        self.config = config\n        self.model_client = model_client\n        self.prompt_template_path = (\n            Path(config.engine.prompts_dir) / \"test_generation.tpl\"\n        )\n\n    def run(self, context: Context) -> Context:\n        if context.should_abort or not context.patch:\n            logger.info(\n                \"TestRole: Context aborted or no patch to test. Skipping.\"\n            )\n            return context\n\n        logger.info(\"TestRole: Generating and applying new tests...\")\n        self._generate_and_apply_tests(context)\n\n        logger.info(\"TestRole: Running all tests...\")\n        self._run_all_tests(context)\n\n        return context\n\n    def _generate_and_apply_tests(self, context: Context):\n        \"\"\"\n        Generates and applies new tests based on the current patch.\n        \"\"\"\n        if not self.prompt_template_path.exists():\n            logger.error(\n                \"TestRole: Test generation prompt not found at %s\",\n                self.prompt_template_path,\n            )\n            return\n\n        prompt_template = self.prompt_template_path.read_text(encoding=\"utf-8\")\n        prompt = prompt_template.format(patch_to_be_tested=context.patch)\n\n        try:\n            test_patch = self.model_client.call_model(\n                self.config.model.model_name, prompt=prompt\n            ).strip()\n\n            if test_patch:\n                logger.info(\"TestRole: Applying generated test patch.\")\n                self._apply_patch(test_patch, os.getcwd())\n            else:\n                logger.warning(\"TestRole: No test patch was generated.\")\n\n        except ModelCallError as e:\n            logger.error(\n                \"TestRole: Model call failed during test generation: %s\", e\n            )\n\n    def _run_all_tests(self, context: Context):\n        \"\"\"\n        Runs the entire pytest test suite.\n        \"\"\"\n        try:\n            result = subprocess.run(\n                [\"pytest\"],\n                cwd=os.getcwd(),\n                capture_output=True,\n                text=True,\n            )\n\n            tests_passed = result.returncode == 0\n            context.test_results = {\n                \"passed\": tests_passed,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"returncode\": result.returncode,\n            }\n\n            if tests_passed:\n                logger.info(\"TestRole: All tests passed successfully.\")\n            else:\n                logger.error(\n                    \"TestRole: Tests failed. Output:\\n%s\\nErrors:\\n%s\",\n                    result.stdout,\n                    result.stderr,\n                )\n\n        except FileNotFoundError:\n            logger.error(\n                \"TestRole: Pytest not found. Please ensure it is installed.\"\n            )\n            context.should_abort = True\n            context.test_results = {\n                \"passed\": False,\n                \"error\": \"pytest not found\",\n            }\n        except Exception as e:\n            logger.exception(\n                \"TestRole: An unexpected error occurred: %s\", e\n            )\n            context.should_abort = True\n            context.test_results = {\"passed\": False, \"error\": str(e)}\n\n    def _apply_patch(self, patch_text: str, cwd: str) -> bool:\n        \"\"\"\n        Applies a patch to the codebase using git apply.\n        This is a simplified version for applying test patches.\n        \"\"\"\n        if not patch_text:\n            return False\n        try:\n            patch_file_path = Path(\"./temp_test.patch\")\n            patch_file_path.write_text(patch_text, encoding=\"utf-8\")\n\n            subprocess.run(\n                [\"git\", \"apply\", str(patch_file_path)],\n                check=True,\n                cwd=cwd,\n                capture_output=True,\n            )\n            patch_file_path.unlink()\n            return True\n        except subprocess.CalledProcessError as e:\n            logger.error(\n                \"Error applying test patch: %s\\n%s\", e, e.stderr.decode()\n            )\n            return False\n        except FileNotFoundError:\n            logger.error(\"Error: git command not found.\")\n            return False\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/roles/test.py",
      "change_type": "modify",
      "description": "Enhance the `test.py` role to execute tests with coverage reporting and capture coverage data for analysis."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/roles/test.py\n+++ b/src/ai_self_ext_engine/roles/test.py\n@@ -5,7 +5,7 @@\n from pathlib import Path\n from ai_self_ext_engine.core.role import Role, Context\n from ai_self_ext_engine.config import MainConfig\n-from ai_self_ext_engine.model_client import ModelClient, ModelCallError\n+from ai_self_ext_engine.model_client import ModelClient, ModelCallError \n \n \n logger = logging.getLogger(__name__)\n@@ -20,6 +20,7 @@\n         self.prompt_template_path = (\n             Path(config.engine.prompts_dir) / \"test_generation.tpl\"\n         )\n+        self.coverage_report_path = Path(os.getcwd()) / \"coverage.xml\"\n \n     def run(self, context: Context) -> Context:\n         if context.should_abort or not context.patch:\n@@ -62,11 +63,18 @@\n \n     def _run_all_tests(self, context: Context):\n         \"\"\"\n-        Runs the entire pytest test suite.\n+        Runs the entire pytest test suite with coverage reporting.\n         \"\"\"\n         try:\n+            # Command to run pytest with coverage\n+            command = [\n+                \"pytest\",\n+                \"--cov=.\",                       # Report coverage for current directory\n+                f\"--cov-report=xml:{self.coverage_report_path}\", # XML report to a file\n+                \"--cov-report=term-missing\",    # Show missing lines in terminal\n+            ]\n+            logger.info(f\"TestRole: Running pytest with command: {' '.join(command)}\")\n             result = subprocess.run(\n-                [\"pytest\"],\n+                command,\n                 cwd=os.getcwd(),\n                 capture_output=True,\n                 text=True,\n@@ -87,13 +95,25 @@\n                     result.stderr,\n                 )\n \n+            # Process coverage report if generated\n+            if self.coverage_report_path.exists():\n+                logger.info(f\"TestRole: Processing coverage report from {self.coverage_report_path}\")\n+                coverage_data = self._parse_coverage_xml(self.coverage_report_path)\n+                if coverage_data:\n+                    context.test_results[\"coverage_data\"] = coverage_data\n+                    logger.info(f\"TestRole: Overall coverage: {coverage_data.get('overall', {}).get('line_rate', 0)*100:.2f}%\")\n+                else:\n+                    logger.warning(\"TestRole: Failed to parse coverage XML or no coverage data found.\")\n+                \n+                # Clean up the coverage XML file\n+                self.coverage_report_path.unlink(missing_ok=True)\n+            else:\n+                logger.warning(\"TestRole: Coverage XML report not found. Pytest-cov might not be installed or no coverage data generated.\")\n+\n         except FileNotFoundError:\n             logger.error(\n-                \"TestRole: Pytest not found. Please ensure it is installed.\"\n+                \"TestRole: Pytest or pytest-cov not found. Please ensure they are installed.\"\n             )\n             context.should_abort = True\n-            context.test_results = {\n-                \"passed\": False,\n-                \"error\": \"pytest not found\",\n-            }\n+            context.test_results = {\"passed\": False, \"error\": \"pytest or pytest-cov not found\"}\n         except Exception as e:\n-            logger.exception(\n-                \"TestRole: An unexpected error occurred: %s\", e\n-            )\n+            logger.exception(\"TestRole: An unexpected error occurred during test execution: %s\", e)\n             context.should_abort = True\n             context.test_results = {\"passed\": False, \"error\": str(e)}\n \n@@ -118,5 +138,40 @@\n         except FileNotFoundError:\n             logger.error(\"Error: git command not found.\")\n             return False\n+    \n+    def _parse_coverage_xml(self, xml_path: Path) -> dict | None:\n+        \"\"\"\n+        Parses a coverage.xml report and extracts key metrics.\n+        \"\"\"\n+        try:\n+            # Lazy import xml.etree.ElementTree to avoid circular dependency\n+            # if Role or Context were to indirectly import something that imports TestRole\n+            # though direct import is fine here as it's a leaf dependency for this use case.\n+            import xml.etree.ElementTree as ET\n+            \n+            tree = ET.parse(xml_path)\n+            root = tree.getroot()\n+\n+            # Find the overall metrics\n+            metrics_element = root.find(\".//metrics\")\n+            if metrics_element is None:\n+                logger.warning(\"TestRole: No <metrics> element found in coverage XML.\")\n+                return None\n+\n+            lines_covered = int(metrics_element.get(\"covered\", 0))\n+            lines_valid = int(metrics_element.get(\"elements\", 0))\n+            line_rate = float(metrics_element.get(\"line-rate\", 0.0))\n+\n+            coverage_data = {\n+                \"overall\": {\n+                    \"line_rate\": line_rate,\n+                    \"lines_covered\": lines_covered,\n+                    \"lines_valid\": lines_valid,\n+                }\n+            }\n+            return coverage_data\n+\n+        except ET.ParseError as e:\n+            logger.error(f\"TestRole: Error parsing coverage XML file {xml_path}: {e}\")\n+            return None\n+        except Exception as e:\n+            logger.error(f\"TestRole: An unexpected error occurred while parsing coverage XML: {e}\")\n+            return None",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}