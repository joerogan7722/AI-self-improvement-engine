{
  "cycle": null,
  "goal_id": "auto_goal_2",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/test_utils.py\nimport subprocess\nimport logging\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\n\nlogger = logging.getLogger(__name__)\n\ndef run_tests(\n    project_root: Path,\n    test_path: Path,\n    coverage_report_dir: Optional[Path] = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Runs pytest tests for the specified path within the project root,\n    optionally generating a coverage report.\n\n    Args:\n        project_root: The root directory of the project. Pytest will be run from here.\n                      Coverage will be measured relative to this root.\n        test_path: The path to the tests (file or directory) relative to `project_root`.\n                   e.g., Path(\"tests/unit/test_my_module.py\") or Path(\"tests/\").\n        coverage_report_dir: Optional path to a directory where the coverage XML report\n                             should be saved. If None, no XML report is generated.\n                             The report will be named '.coverage.xml' within this directory.\n\n    Returns:\n        A dictionary containing:\n        - 'success': bool, True if tests passed (return code 0), False otherwise.\n        - 'stdout': str, The standard output from the pytest command.\n        - 'stderr': str, The standard error from the pytest command.\n        - 'coverage_xml_path': Optional[Path], The path to the generated coverage XML report,\n                               if requested and successfully created.\n    \"\"\"\n    results: Dict[str, Any] = {\n        'success': False,\n        'stdout': '',\n        'stderr': '',\n        'coverage_xml_path': None\n    }\n\n    # Ensure pytest is available\n    try:\n        subprocess.run([\"pytest\", \"--version\"], check=True, capture_output=True)\n    except FileNotFoundError:\n        logger.error(\"Pytest is not installed or not in PATH. Please install it (e.g., pip install pytest pytest-cov).\")\n        results['stderr'] = \"Pytest not found.\"\n        return results\n    except subprocess.CalledProcessError as e:\n        logger.error(f\"Error checking pytest version: {e.stderr.decode()}\")\n        results['stderr'] = f\"Error checking pytest version: {e.stderr.decode()}\"\n        return results\n\n    # Construct the pytest command\n    cmd = [\"pytest\"]\n\n    if coverage_report_dir:\n        # Ensure coverage directory exists\n        coverage_report_dir.mkdir(parents=True, exist_ok=True)\n        coverage_xml_path = coverage_report_dir / \".coverage.xml\"\n\n        # Add coverage flags\n        # --cov=. will measure coverage for the entire project from project_root\n        # --cov-report=xml:path/to/.coverage.xml will save the report\n        # --cov-report=term-missing will show missing lines in console\n        cmd.extend([\n            f\"--cov={project_root}\",\n            f\"--cov-report=xml:{coverage_xml_path}\",\n            \"--cov-report=term-missing\"\n        ])\n\n    cmd.append(str(test_path)) # Add the specific test path or directory\n\n    logger.info(f\"Running tests from '{test_path}' with command: {' '.join(cmd)} in directory '{project_root}'\")\n\n    try:\n        process = subprocess.run(cmd, cwd=project_root, capture_output=True, text=True, check=False)\n        results['stdout'] = process.stdout\n        results['stderr'] = process.stderr\n        results['success'] = process.returncode == 0\n        if results['success'] and coverage_report_dir:\n            results['coverage_xml_path'] = coverage_xml_path\n    except Exception as e:\n        logger.exception(f\"An unexpected error occurred while running tests for {test_path}: {e}\")\n        results['stderr'] += f\"\\nAn unexpected error occurred: {e}\"\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/test_utils.py",
      "change_type": "modify",
      "description": "Add a utility function to run tests with coverage and return the coverage report data (e.g., as a dictionary or Coverage.report() output)."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/test_utils.py\n+++ b/src/ai_self_ext_engine/test_utils.py\n@@ -2,7 +2,8 @@\n import subprocess\n import logging\n from pathlib import Path\n-from typing import Optional, Dict, Any\n+from typing import Optional, Dict, Any, Union\n+import xml.etree.ElementTree as ET\n \n logger = logging.getLogger(__name__)\n \n@@ -10,7 +11,7 @@\n     project_root: Path,\n     test_path: Path,\n     coverage_report_dir: Optional[Path] = None\n-) -> Dict[str, Any]:\n+) -> Dict[str, Union[bool, str, Path, Dict[str, Any], None]]:\n     \"\"\"\n     Runs pytest tests for the specified path within the project root,\n     optionally generating a coverage report.\n@@ -25,12 +26,14 @@\n                              The report will be named '.coverage.xml' within this directory.\n \n     Returns:\n         A dictionary containing:\n         - 'success': bool, True if tests passed (return code 0), False otherwise.\n         - 'stdout': str, The standard output from the pytest command.\n         - 'stderr': str, The standard error from the pytest command.\n         - 'coverage_xml_path': Optional[Path], The path to the generated coverage XML report,\n                                if requested and successfully created.\n+        - 'coverage_data': Optional[Dict], Parsed coverage report data if coverage was\n+                           requested and successfully generated.\n     \"\"\"\n     results: Dict[str, Any] = {\n         'success': False,\n         'stdout': '',\n         'stderr': '',\n-        'coverage_xml_path': None\n+        'coverage_xml_path': None,\n+        'coverage_data': None # New field for parsed coverage data\n     }\n \n     # Ensure pytest is available\n     try:\n         subprocess.run([\"pytest\", \"--version\"], check=True, capture_output=True)\n     except FileNotFoundError:\n@@ -48,6 +51,7 @@\n \n     # Construct the pytest command\n     cmd = [\"pytest\"]\n+    coverage_xml_path: Optional[Path] = None # Define it here to be accessible after subprocess.run\n \n     if coverage_report_dir:\n         # Ensure coverage directory exists\n@@ -69,10 +73,63 @@\n         results['stdout'] = process.stdout\n         results['stderr'] = process.stderr\n         results['success'] = process.returncode == 0\n-        if results['success'] and coverage_report_dir:\n+\n+        if results['success'] and coverage_xml_path and coverage_xml_path.exists():\n             results['coverage_xml_path'] = coverage_xml_path\n             \n+            # Parse coverage XML report\n             try:\n+                tree = ET.parse(coverage_xml_path)\n+                root = tree.getroot()\n+                \n+                # Extract overall coverage metrics from the root element\n+                overall_line_rate = float(root.get('line-rate', '0.0'))\n+                overall_lines_covered = int(root.get('lines-covered', '0'))\n+                overall_lines_valid = int(root.get('lines-valid', '0'))\n+\n+                coverage_data = {\n+                    'overall': {\n+                        'line_rate': overall_line_rate,\n+                        'lines_covered': overall_lines_covered,\n+                        'lines_valid': overall_lines_valid,\n+                    },\n+                    'files': []\n+                }\n+                \n+                # Extract per-file coverage metrics\n+                for package_elem in root.findall('./packages/package'):\n+                    for class_elem in package_elem.findall('./classes/class'):\n+                        filename = class_elem.get('filename')\n+                        file_line_rate = float(class_elem.get('line-rate', '0.0'))\n+                        file_lines_covered = int(class_elem.get('lines-covered', '0'))\n+                        file_lines_valid = int(class_elem.get('lines-valid', '0'))\n+                        \n+                        # Normalize filename path to be relative to project_root if possible\n+                        if filename:\n+                            try:\n+                                # If filename is absolute, try to make it relative to project_root\n+                                abs_filename_path = Path(filename)\n+                                if abs_filename_path.is_absolute():\n+                                    relative_filename = abs_filename_path.relative_to(project_root)\n+                                    filename = str(relative_filename)\n+                                # If filename is already relative, Path(filename) is fine.\n+                            except ValueError:\n+                                # filename is not directly relative to project_root (e.g., from a different drive/path)\n+                                # For now, just keep original path as reported by coverage.\n+                                pass\n+\n+                        file_data = {\n+                            'filename': filename,\n+                            'line_rate': file_line_rate,\n+                            'lines_covered': file_lines_covered,\n+                            'lines_valid': file_lines_valid,\n+                        }\n+                        coverage_data['files'].append(file_data)\n+                            \n+                results['coverage_data'] = coverage_data\n+                logger.info(f\"Successfully parsed coverage report from {coverage_xml_path}\")\n+\n+            except ET.ParseError as pe:\n+                logger.error(f\"Error parsing coverage XML report from {coverage_xml_path}: {pe}\")\n+            except Exception as parse_e:\n+                logger.exception(f\"An unexpected error occurred while parsing coverage report: {parse_e}\")\n+        elif coverage_xml_path and not coverage_xml_path.exists():\n+            logger.warning(f\"Coverage XML report was requested but not found at {coverage_xml_path}. Check if covered files exist or if tests actually ran and hit python files.\")\n     except Exception as e:\n         logger.exception(f\"An unexpected error occurred while running tests for {test_path}: {e}\")\n         results['stderr'] += f\"\\nAn unexpected error occurred: {e}\"",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}