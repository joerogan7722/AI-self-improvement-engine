{
  "cycle": null,
  "goal_id": "auto_goal_2",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/roles/test.py\nimport subprocess\nimport os\nimport logging\nfrom pathlib import Path\nfrom ai_self_ext_engine.core.role import Role, Context\nfrom ai_self_ext_engine.config import MainConfig\nfrom ai_self_ext_engine.model_client import ModelClient, ModelCallError\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass TestRole(Role):\n    \"\"\"\n    Role responsible for generating and running tests on the codebase.\n    \"\"\"\n\n    def __init__(self, config: MainConfig, model_client: ModelClient):\n        self.config = config\n        self.model_client = model_client\n        self.prompt_template_path = (\n            Path(config.engine.prompts_dir) / \"test_generation.tpl\"\n        )\n\n    def run(self, context: Context) -> Context:\n        if context.should_abort or not context.patch:\n            logger.info(\n                \"TestRole: Context aborted or no patch to test. Skipping.\"\n            )\n            return context\n\n        logger.info(\"TestRole: Generating and applying new tests...\")\n        self._generate_and_apply_tests(context)\n\n        logger.info(\"TestRole: Running all tests...\")\n        self._run_all_tests(context)\n\n        return context\n\n    def _generate_and_apply_tests(self, context: Context):\n        \"\"\"\n        Generates and applies new tests based on the current patch.\n        \"\"\"\n        if not self.prompt_template_path.exists():\n            logger.error(\n                \"TestRole: Test generation prompt not found at %s\",\n                self.prompt_template_path,\n            )\n            return\n\n        prompt_template = self.prompt_template_path.read_text(encoding=\"utf-8\")\n        prompt = prompt_template.format(patch_to_be_tested=context.patch)\n\n        try:\n            test_patch = self.model_client.call_model(\n                self.config.model.model_name, prompt=prompt\n            ).strip()\n\n            if test_patch:\n                logger.info(\"TestRole: Applying generated test patch.\")\n                self._apply_patch(test_patch, os.getcwd())\n            else:\n                logger.warning(\"TestRole: No test patch was generated.\")\n\n        except ModelCallError as e:\n            logger.error(\n                \"TestRole: Model call failed during test generation: %s\", e\n            )\n\n    def _run_all_tests(self, context: Context):\n        \"\"\"\n        Runs the entire pytest test suite.\n        \"\"\"\n        try:\n            result = subprocess.run(\n                [\"pytest\"],\n                cwd=os.getcwd(),\n                capture_output=True,\n                text=True,\n            )\n\n            tests_passed = result.returncode == 0\n            context.test_results = {\n                \"passed\": tests_passed,\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"returncode\": result.returncode,\n            }\n\n            if tests_passed:\n                logger.info(\"TestRole: All tests passed successfully.\")\n            else:\n                logger.error(\n                    \"TestRole: Tests failed. Output:\\n%s\\nErrors:\\n%s\",\n                    result.stdout,\n                    result.stderr,\n                )\n\n        except FileNotFoundError:\n            logger.error(\n                \"TestRole: Pytest not found. Please ensure it is installed.\"\n            )\n            context.should_abort = True\n            context.test_results = {\n                \"passed\": False,\n                \"error\": \"pytest not found\",\n            }\n        except Exception as e:\n            logger.exception(\n                \"TestRole: An unexpected error occurred: %s\", e\n            )\n            context.should_abort = True\n            context.test_results = {\"passed\": False, \"error\": str(e)}\n\n    def _apply_patch(self, patch_text: str, cwd: str) -> bool:\n        \"\"\"\n        Applies a patch to the codebase using git apply.\n        This is a simplified version for applying test patches.\n        \"\"\"\n        if not patch_text:\n            return False\n        try:\n            patch_file_path = Path(\"./temp_test.patch\")\n            patch_file_path.write_text(patch_text, encoding=\"utf-8\")\n\n            subprocess.run(\n                [\"git\", \"apply\", str(patch_file_path)],\n                check=True,\n                cwd=cwd,\n                capture_output=True,\n            )\n            patch_file_path.unlink()\n            return True\n        except subprocess.CalledProcessError as e:\n            logger.error(\n                \"Error applying test patch: %s\\n%s\", e, e.stderr.decode()\n            )\n            return False\n        except FileNotFoundError:\n            logger.error(\"Error: git command not found.\")\n            return False\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/roles/test.py",
      "change_type": "modify",
      "description": "Integrate test coverage measurement into the 'test' role's execution process to collect coverage data when running tests."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/roles/test.py\n+++ b/src/ai_self_ext_engine/roles/test.py\n@@ -3,6 +3,8 @@\n import os\n import logging\n from pathlib import Path\n+import tempfile\n+import shutil\n from ai_self_ext_engine.core.role import Role, Context\n from ai_self_ext_engine.config import MainConfig\n from ai_self_ext_engine.model_client import ModelClient, ModelCallError\n@@ -69,49 +71,76 @@\n                 \"TestRole: Model call failed during test generation: %s\", e\n             )\n \n     def _run_all_tests(self, context: Context):\n         \"\"\"\n-        Runs the entire pytest test suite.\n+        Runs the entire pytest test suite and collects coverage.\n         \"\"\"\n+        coverage_dir = None\n         try:\n+            # Create a temporary directory for coverage reports\n+            coverage_dir = Path(tempfile.mkdtemp(prefix=\"coverage_\"))\n+            coverage_xml_path = coverage_dir / \"coverage.xml\"\n+            coverage_html_path = coverage_dir / \"htmlcov\"\n+\n+            cmd = [\n+                \"pytest\",\n+                f\"--cov={os.getcwd()}\",  # Measure coverage for the entire project from cwd\n+                f\"--cov-report=xml:{coverage_xml_path}\",\n+                f\"--cov-report=html:{coverage_html_path}\",\n+                \"--cov-report=term-missing\",  # Also show missing lines in terminal output\n+            ]\n+\n+            logger.info(f\"TestRole: Running pytest with coverage: {' '.join(cmd)}\")\n+\n             result = subprocess.run(\n-                [\"pytest\"],\n+                cmd,\n                 cwd=os.getcwd(),\n                 capture_output=True,\n                 text=True,\n             )\n \n             tests_passed = result.returncode == 0\n             context.test_results = {\n                 \"passed\": tests_passed,\n                 \"stdout\": result.stdout,\n                 \"stderr\": result.stderr,\n                 \"returncode\": result.returncode,\n+                \"coverage_xml_path\": str(coverage_xml_path)\n+                if coverage_xml_path.exists()\n+                else None,\n+                \"coverage_html_path\": str(coverage_html_path)\n+                if coverage_html_path.exists()\n+                else None,\n             }\n \n             if tests_passed:\n                 logger.info(\"TestRole: All tests passed successfully.\")\n             else:\n                 logger.error(\n                     \"TestRole: Tests failed. Output:\\n%s\\nErrors:\\n%s\",\n                     result.stdout,\n                     result.stderr,\n                 )\n+            if coverage_xml_path.exists():\n+                logger.info(f\"TestRole: Coverage XML report generated at {coverage_xml_path}\")\n+            if coverage_html_path.exists():\n+                logger.info(f\"TestRole: Coverage HTML report generated at {coverage_html_path}\")\n \n         except FileNotFoundError:\n             logger.error(\n-                \"TestRole: Pytest not found. Please ensure it is installed.\"\n+                \"TestRole: Pytest or coverage tool not found. Please ensure they are installed (`pip install pytest pytest-cov`).\"\n             )\n             context.should_abort = True\n             context.test_results = {\n                 \"passed\": False,\n-                \"error\": \"pytest not found\",\n+                \"error\": \"pytest or pytest-cov not found\",\n             }\n         except Exception as e:\n             logger.exception(\n-                \"TestRole: An unexpected error occurred: %s\", e\n+                \"TestRole: An unexpected error occurred during test run with coverage: %s\",\n+                e,\n             )\n             context.should_abort = True\n             context.test_results = {\"passed\": False, \"error\": str(e)}\n+        finally:\n+            if coverage_dir and coverage_dir.exists():\n+                try:\n+                    shutil.rmtree(coverage_dir)\n+                    logger.info(\n+                        f\"TestRole: Cleaned up temporary coverage directory: {coverage_dir}\"\n+                    )\n+                except OSError as e:\n+                    logger.warning(\n+                        f\"TestRole: Failed to clean up temporary coverage directory {coverage_dir}: {e}\"\n+                    )\n \n     def _apply_patch(self, patch_text: str, cwd: str) -> bool:\n         \"\"\"",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}