{
  "cycle": null,
  "goal_id": "auto_goal_2",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/cli.py\nimport argparse\nfrom pathlib import Path\nimport os\nimport sys\nimport yaml\nimport logging # New import\nimport json # New import for JSON formatter\nfrom datetime import datetime # New import for JSON formatter\nfrom pydantic import ValidationError # Import ValidationError\n\nfrom .config import MainConfig, LoggingConfig\nfrom .core.engine import Engine\n\n# Set up a logger for the CLI module\nlogger = logging.getLogger(__name__)\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"A custom logging formatter that outputs logs in JSON format.\"\"\"\n    def format(self, record):\n        log_record = {\n            \"timestamp\": datetime.fromtimestamp(record.created).isoformat(),\n            \"level\": record.levelname,\n            \"name\": record.name,\n            \"message\": record.getMessage(),\n        }\n        if record.exc_info:\n            log_record[\"exc_info\"] = self.formatException(record.exc_info)\n        if record.stack_info:\n            log_record[\"stack_info\"] = self.formatStack(record.stack_info)\n\n        return json.dumps(log_record)\n\ndef _setup_logging(log_config: LoggingConfig):\n    \"\"\"Configures the root logger based on the provided logging configuration.\"\"\"\n    level_map = {level: getattr(logging, level.upper()) for level in [\"debug\", \"info\", \"warning\", \"error\", \"critical\"]}\n    log_level = level_map.get(log_config.level.lower(), logging.INFO)\n\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n    for handler in root_logger.handlers[:]: # Clear existing handlers\n        root_logger.removeHandler(handler)\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stderr)\n    console_handler.setLevel(log_level)\n\n    if log_config.format == \"json\":\n        formatter = JsonFormatter()\n    else:\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(message)s')\n\n    console_handler.setFormatter(formatter)\n    root_logger.addHandler(console_handler)\n\n    # File handler (if log_file is specified)\n    if log_config.log_file:\n        log_file_path = Path(log_config.log_file)\n        log_file_path.parent.mkdir(parents=True, exist_ok=True) # Ensure log directory exists\n        file_handler = logging.FileHandler(log_file_path, encoding='utf-8')\n        file_handler.setLevel(log_level)\n        file_handler.setFormatter(formatter)\n        root_logger.addHandler(file_handler)\n\n    logger.info(\"Logging configured to level '%s' with format '%s'. Outputting to console and %s.\", \n                log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n    parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n                        help=\"Path to the engine configuration file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", \n                        help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n    args = parser.parse_args()\n\n    # Load and validate configuration\n    config: MainConfig\n    try:\n        config_path = Path(args.config)\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n        \n        with open(config_path, 'r', encoding='utf-8') as f:\n            config_data = yaml.safe_load(f)\n        \n        config = MainConfig(**config_data) # Use MainConfig for validation\n\n        # Override log level if --verbose flag is set\n        if args.verbose:\n            config.logging.level = \"DEBUG\"\n\n        # Configure logging as early as possible after config is loaded\n        _setup_logging(config.logging)\n\n    except FileNotFoundError as e:\n        logger.error(\"Error: Config file not found at %s. %s\", config_path.absolute(), e, exc_info=False)\n        sys.exit(1)\n    except ValidationError as e:\n        logger.error(\"Configuration validation error: %s\", e, exc_info=True)\n        sys.exit(1)\n    except Exception as e:\n        logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n        sys.exit(1)\n\n    engine = Engine(config)\n    engine.run_cycles()\n\nif __name__ == \"__main__\":\n    main()\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/cli.py",
      "change_type": "modify",
      "description": "Add a new CLI command or extend an existing test command to execute tests with coverage measurement and generate coverage reports."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/cli.py\n+++ b/src/ai_self_ext_engine/cli.py\n@@ -5,6 +5,7 @@\n import yaml\n import logging # New import\n import json # New import for JSON formatter\n+import subprocess # New import for running external commands\n from datetime import datetime # New import for JSON formatter\n from pydantic import ValidationError # Import ValidationError\n \n@@ -58,11 +59,50 @@\n     logger.info(\"Logging configured to level '%s' with format '%s'. Outputting to console and %s.\", \n                 log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n \n+def _run_tests_with_coverage(test_target: str, config_file_path: Path) -> int:\n+    \"\"\"\n+    Runs pytest with coverage and generates reports.\n+\n+    Args:\n+        test_target: The path to run tests on (e.g., '.', 'tests/').\n+        config_file_path: The path to the main configuration file, used to determine\n+                          the base directory for placing reports (e.g., 'config/engine_config.yaml').\n+\n+    Returns:\n+        The exit code of the pytest process.\n+    \"\"\"\n+    try:\n+        # Determine the base directory for reports (project root, assuming config is in <project_root>/config/)\n+        project_root_for_reports = config_file_path.parent.parent\n+        report_dir = project_root_for_reports / \"reports\"\n+        report_dir.mkdir(parents=True, exist_ok=True)\n+        \n+        coverage_xml_path = report_dir / \"coverage.xml\"\n+        coverage_html_dir = report_dir / \"htmlcov\"\n+\n+        # The project source directory to measure coverage for is src/ai_self_ext_engine/\n+        coverage_measure_path = Path(__file__).parent.as_posix()\n+\n+        cmd = [\n+            sys.executable, \"-m\", \"pytest\",\n+            test_target,\n+            f\"--cov={coverage_measure_path}\",\n+            \"--cov-report=term-missing\",\n+            f\"--cov-report=xml:{coverage_xml_path}\",\n+            f\"--cov-report=html:{coverage_html_dir}\",\n+            \"--durations=0\",\n+        ]\n+        \n+        logger.info(\"Running tests with coverage: %s\", \" \".join(cmd))\n+        process = subprocess.run(cmd, capture_output=True, text=True, check=False)\n+        \n+        if process.stdout: logger.info(\"Pytest Output:\\n%s\", process.stdout)\n+        if process.stderr: logger.error(\"Pytest Errors:\\n%s\", process.stderr)\n+\n+        logger.info(\"Coverage XML report generated at: %s\", coverage_xml_path.absolute())\n+        logger.info(\"Coverage HTML report generated at: %s\", coverage_html_dir.absolute())\n+        return process.returncode\n+    except FileNotFoundError:\n+        logger.error(\"Error: 'pytest' or 'python' command not found. Please ensure pytest and pytest-cov are installed (`pip install pytest pytest-cov`).\")\n+        return 1\n+    except Exception as e:\n+        logger.exception(\"An unexpected error occurred during test execution: %s\", e)\n+        return 1\n+\n def main():\n     parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n     parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n                         help=\"Path to the engine configuration file.\")\n     parser.add_argument(\"--verbose\", action=\"store_true\", \n                         help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n+    parser.add_argument(\"--test\", nargs=\"?\", const=\".\", default=None,\n+                        help=\"Run tests with coverage. Optionally specify a path or '.' for all tests. \"\n+                             \"Generates XML and HTML coverage reports in a 'reports/' directory at the project root.\")\n     args = parser.parse_args()\n \n     # Load and validate configuration\n@@ -89,6 +129,11 @@\n         logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n         sys.exit(1)\n \n+    # Handle --test argument, if present\n+    if args.test is not None:\n+        logger.info(f\"Test mode activated. Running tests in '{args.test}' with coverage.\")\n+        exit_code = _run_tests_with_coverage(args.test, config_path)\n+        sys.exit(exit_code)\n+\n     engine = Engine(config)\n     engine.run_cycles()",
  "test_results": {
    "passed": false,
    "error": "pytest not found"
  },
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}