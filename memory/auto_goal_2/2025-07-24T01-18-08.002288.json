{
  "cycle": null,
  "goal_id": "auto_goal_2",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/cli.py\nimport argparse\nfrom pathlib import Path\nimport os\nimport sys\nimport yaml\nimport logging # New import\nimport json # New import for JSON formatter\nfrom datetime import datetime # New import for JSON formatter\nfrom pydantic import ValidationError # Import ValidationError\n\nfrom .config import MainConfig, LoggingConfig\nfrom .core.engine import Engine\n\n# Set up a logger for the CLI module\nlogger = logging.getLogger(__name__)\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"A custom logging formatter that outputs logs in JSON format.\"\"\"\n    def format(self, record):\n        log_record = {\n            \"timestamp\": datetime.fromtimestamp(record.created).isoformat(),\n            \"level\": record.levelname,\n            \"name\": record.name,\n            \"message\": record.getMessage(),\n        }\n        if record.exc_info:\n            log_record[\"exc_info\"] = self.formatException(record.exc_info)\n        if record.stack_info:\n            log_record[\"stack_info\"] = self.formatStack(record.stack_info)\n\n        return json.dumps(log_record)\n\ndef _setup_logging(log_config: LoggingConfig):\n    \"\"\"Configures the root logger based on the provided logging configuration.\"\"\"\n    level_map = {level: getattr(logging, level.upper()) for level in [\"debug\", \"info\", \"warning\", \"error\", \"critical\"]}\n    log_level = level_map.get(log_config.level.lower(), logging.INFO)\n\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n    for handler in root_logger.handlers[:]: # Clear existing handlers\n        root_logger.removeHandler(handler)\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stderr)\n    console_handler.setLevel(log_level)\n\n    if log_config.format == \"json\":\n        formatter = JsonFormatter()\n    else:\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(message)s')\n\n    console_handler.setFormatter(formatter)\n    root_logger.addHandler(console_handler)\n\n    # File handler (if log_file is specified)\n    if log_config.log_file:\n        log_file_path = Path(log_config.log_file)\n        log_file_path.parent.mkdir(parents=True, exist_ok=True) # Ensure log directory exists\n        file_handler = logging.FileHandler(log_file_path, encoding='utf-8')\n        file_handler.setLevel(log_level)\n        file_handler.setFormatter(formatter)\n        root_logger.addHandler(file_handler)\n\n    logger.info(\"Logging configured to level '%s' with format '%s'. Outputting to console and %s.\", \n                log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n    parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n                        help=\"Path to the engine configuration file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", \n                        help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n    args = parser.parse_args()\n\n    # Load and validate configuration\n    config: MainConfig\n    try:\n        config_path = Path(args.config)\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n        \n        with open(config_path, 'r', encoding='utf-8') as f:\n            config_data = yaml.safe_load(f)\n        \n        config = MainConfig(**config_data) # Use MainConfig for validation\n\n        # Override log level if --verbose flag is set\n        if args.verbose:\n            config.logging.level = \"DEBUG\"\n\n        # Configure logging as early as possible after config is loaded\n        _setup_logging(config.logging)\n\n    except FileNotFoundError as e:\n        logger.error(\"Error: Config file not found at %s. %s\", config_path.absolute(), e, exc_info=False)\n        sys.exit(1)\n    except ValidationError as e:\n        logger.error(\"Configuration validation error: %s\", e, exc_info=True)\n        sys.exit(1)\n    except Exception as e:\n        logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n        sys.exit(1)\n\n    engine = Engine(config)\n    engine.run_cycles()\n\nif __name__ == \"__main__\":\n    main()\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/cli.py",
      "change_type": "modify",
      "description": "Add a CLI command to run unit tests with code coverage reporting, enabling analysis of current test coverage."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/cli.py\n+++ b/src/ai_self_ext_engine/cli.py\n@@ -10,6 +10,7 @@\n \n from .config import MainConfig, LoggingConfig\n from .core.engine import Engine\n+from . import test_utils # New import for running tests and coverage\n \n # Set up a logger for the CLI module\n logger = logging.getLogger(__name__)\n@@ -69,56 +70,105 @@\n     logger.info(\"Logging configured to level '%s' with format '%s'. Outputting to console and %s.\", \n                 log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n \n+def _handle_run_command(args):\n+    \"\"\"Handles the 'run' command to start the engine.\"\"\"\n+    config: MainConfig\n+    try:\n+        config_path = Path(args.config)\n+        if not config_path.exists():\n+            raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n+        \n+        with open(config_path, 'r', encoding='utf-8') as f:\n+            config_data = yaml.safe_load(f)\n+        \n+        config = MainConfig(**config_data) # Use MainConfig for validation\n+\n+        # Override log level if --verbose flag is set\n+        if args.verbose:\n+            config.logging.level = \"DEBUG\"\n+\n+        # Configure logging as early as possible after config is loaded\n+        _setup_logging(config.logging)\n+\n+    except FileNotFoundError as e:\n+        logger.error(\"Error: Config file not found at %s. %s\", config_path.absolute(), e, exc_info=False)\n+        sys.exit(1)\n+    except ValidationError as e:\n+        logger.error(\"Configuration validation error: %s\", e, exc_info=True)\n+        sys.exit(1)\n+    except Exception as e:\n+        logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n+        sys.exit(1)\n+\n+    engine = Engine(config)\n+    engine.run_cycles()\n+\n+def _handle_coverage_command(args):\n+    \"\"\"Handles the 'coverage' command to run unit tests and generate a coverage report.\"\"\"\n+    # Configure basic logging for the test command\n+    _setup_logging(LoggingConfig(level=\"INFO\", format=\"text\"))\n+\n+    project_root = Path(__file__).resolve().parent.parent.parent # Assuming project root is 3 levels up from cli.py\n+    \n+    test_path = project_root / args.path\n+    coverage_output_dir = None\n+    if args.output_dir:\n+        coverage_output_dir = project_root / args.output_dir\n+        logger.info(f\"Coverage report will be generated in: {coverage_output_dir}\")\n+\n+    logger.info(f\"Running tests from: {test_path}\")\n+    results = test_utils.run_tests(\n+        project_root=project_root,\n+        test_path=test_path,\n+        coverage_output_dir=coverage_output_dir,\n+        generate_html_report=args.html\n+    )\n+\n+    logger.info(\"\\n--- Test Results ---\")\n+    if results['stdout']:\n+        logger.info(\"STDOUT:\\n%s\", results['stdout'])\n+    if results['stderr']:\n+        logger.error(\"STDERR:\\n%s\", results['stderr'])\n+    \n+    if results['success']:\n+        logger.info(\"Tests completed successfully.\")\n+        if results.get('coverage_xml_path'):\n+            logger.info(f\"Coverage XML report generated at: {results['coverage_xml_path']}\")\n+        if results.get('coverage_html_path'):\n+            logger.info(f\"Coverage HTML report generated at: {results['coverage_html_path']}\")\n+        sys.exit(0)\n+    else:\n+        logger.error(\"Tests failed.\")\n+        sys.exit(1)\n+\n def main():\n     parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n-    parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n-                        help=\"Path to the engine configuration file.\")\n-    parser.add_argument(\"--verbose\", action=\"store_true\", \n-                        help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n+    \n+    # Set default values for the main parser if no subcommand is given\n+    parser.set_defaults(func=_handle_run_command,\n+                        config=\"config/engine_config.yaml\", # Default config for run\n+                        verbose=False) # Default verbose for run\n+\n+    subparsers = parser.add_subparsers(dest=\"command\", help=\"Available commands\")\n+\n+    # 'run' command parser\n+    run_parser = subparsers.add_parser(\"run\", help=\"Run the AI Self-Extending Engine (default command)\")\n+    run_parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n+                            help=\"Path to the engine configuration file.\")\n+    run_parser.add_argument(\"--verbose\", action=\"store_true\", \n+                            help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n+    run_parser.set_defaults(func=_handle_run_command) # This overrides main parser's func if 'run' is explicitly given\n+\n+    # 'coverage' command parser\n+    coverage_parser = subparsers.add_parser(\"coverage\", help=\"Run tests and generate a code coverage report\")\n+    coverage_parser.add_argument(\"--path\", type=Path, default=\"tests/\",\n+                                 help=\"Path to the tests (file or directory) relative to the project root. Default: 'tests/'\")\n+    coverage_parser.add_argument(\"--output-dir\", type=Path, default=\"coverage_report\",\n+                                 help=\"Directory to save the coverage XML and HTML reports. Default: 'coverage_report'\")\n+    coverage_parser.add_argument(\"--html\", action=\"store_true\", help=\"Generate HTML coverage report in --output-dir.\")\n+    coverage_parser.set_defaults(func=_handle_coverage_command)\n+\n     args = parser.parse_args()\n \n-    # Load and validate configuration\n-    config: MainConfig\n-    try:\n-        config_path = Path(args.config)\n-        if not config_path.exists():\n-            raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n-        \n-        with open(config_path, 'r', encoding='utf-8') as f:\n-            config_data = yaml.safe_load(f)\n-        \n-        config = MainConfig(**config_data) # Use MainConfig for validation\n-\n-        # Override log level if --verbose flag is set\n-        if args.verbose:\n-            config.logging.level = \"DEBUG\"\n-\n-        # Configure logging as early as possible after config is loaded\n-        _setup_logging(config.logging)\n-\n-    except FileNotFoundError as e:\n-        logger.error(\"Error: Config file not found at %s. %s\", config_path.absolute(), e, exc_info=False)\n-        sys.exit(1)\n-    except ValidationError as e:\n-        logger.error(\"Configuration validation error: %s\", e, exc_info=True)\n-        sys.exit(1)\n-    except Exception as e:\n-        logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n-        sys.exit(1)\n-\n-    engine = Engine(config)\n-    engine.run_cycles()\n-\n+    # Call the function associated with the chosen subcommand, or the default one.\n+    if hasattr(args, 'func'):\n+        args.func(args)\n+    else:\n+        parser.print_help() # Or you could call _handle_run_command(args) directly for a non-explicit run\n+        sys.exit(1)\n+\n if __name__ == \"__main__\":\n     main()\n--- /dev/null\n+++ b/src/ai_self_ext_engine/test_utils.py\n@@ -0,0 +1,89 @@\n+import subprocess\n+import logging\n+from pathlib import Path\n+from typing import Optional, Dict, Any\n+\n+logger = logging.getLogger(__name__)\n+\n+def run_tests(\n+    project_root: Path,\n+    test_path: Path,\n+    coverage_output_dir: Optional[Path] = None,\n+    generate_html_report: bool = False\n+) -> Dict[str, Any]:\n+    \"\"\"\n+    Runs pytest tests for the specified path within the project root,\n+    optionally generating a comprehensive code coverage report (XML and HTML).\n+\n+    Args:\n+        project_root: The root directory of the project. Pytest will be run from here.\n+                      Coverage will be measured relative to this root.\n+        test_path: The path to the tests (file or directory) relative to `project_root`.\n+                   e.g., Path(\"tests/unit/test_my_module.py\") or Path(\"tests/\").\n+        coverage_output_dir: Optional path to a directory where the coverage XML and HTML reports\n+                             should be saved. If None, no coverage reports are generated.\n+                             The XML report will be named '.coverage.xml' and HTML in 'htmlcov' within this directory.\n+        generate_html_report: If True, an HTML coverage report will be generated in a subdirectory\n+                              named 'htmlcov' within `coverage_output_dir`.\n+\n+    Returns:\n+        A dictionary containing:\n+        - 'success': bool, True if tests passed (return code 0), False otherwise.\n+        - 'stdout': str, The standard output from the pytest command.\n+        - 'stderr': str, The standard error from the pytest command.\n+        - 'coverage_xml_path': Optional[Path], The path to the generated coverage XML report,\n+                               if requested and successfully created.\n+        - 'coverage_html_path': Optional[Path], The path to the generated coverage HTML report directory,\n+                                if requested and successfully created.\n+    \"\"\"\n+    results: Dict[str, Any] = {\n+        'success': False,\n+        'stdout': '',\n+        'stderr': '',\n+        'coverage_xml_path': None,\n+        'coverage_html_path': None\n+    }\n+\n+    # Ensure pytest is available\n+    try:\n+        subprocess.run([\"pytest\", \"--version\"], check=True, capture_output=True)\n+    except FileNotFoundError:\n+        logger.error(\"Pytest is not installed or not in PATH. Please install it (e.g., pip install pytest pytest-cov).\")\n+        results['stderr'] = \"Pytest not found.\"\n+        return results\n+    except subprocess.CalledProcessError as e:\n+        logger.error(f\"Error checking pytest version: {e.stderr.decode()}\")\n+        results['stderr'] = f\"Error checking pytest version: {e.stderr.decode()}\"\n+        return results\n+\n+    # Construct the pytest command\n+    cmd = [\"pytest\"]\n+\n+    if coverage_output_dir:\n+        # Ensure coverage directory exists\n+        coverage_output_dir.mkdir(parents=True, exist_ok=True)\n+        \n+        coverage_xml_path = coverage_output_dir / \".coverage.xml\"\n+        \n+        # Add coverage flags\n+        # --cov={project_root} will measure coverage for the entire project from project_root\n+        # --cov-report=xml:{path} will save the XML report\n+        # --cov-report=term-missing will show missing lines in console\n+        cmd.extend([\n+            f\"--cov={project_root}\",\n+            f\"--cov-report=xml:{coverage_xml_path}\",\n+            \"--cov-report=term-missing\"\n+        ])\n+        if generate_html_report:\n+            coverage_html_path = coverage_output_dir / \"htmlcov\"\n+            cmd.append(f\"--cov-report=html:{coverage_html_path}\")\n+\n+    cmd.append(str(test_path)) # Add the specific test path or directory\n+\n+    logger.info(f\"Running tests from '{test_path}' with command: {' '.join(cmd)} in directory '{project_root}'\")\n+\n+    try:\n+        process = subprocess.run(cmd, cwd=project_root, capture_output=True, text=True, check=False)\n+        results['stdout'] = process.stdout\n+        results['stderr'] = process.stderr\n+        results['success'] = process.returncode == 0\n+        if results['success'] and coverage_output_dir:\n+            results['coverage_xml_path'] = coverage_xml_path\n+            if generate_html_report:\n+                results['coverage_html_path'] = coverage_html_path\n+    except Exception as e:\n+        logger.exception(f\"An unexpected error occurred while running tests for {test_path}: {e}\")\n+        results['stderr'] += f\"\\nAn unexpected error occurred: {e}\"\n+\n+    return results",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}