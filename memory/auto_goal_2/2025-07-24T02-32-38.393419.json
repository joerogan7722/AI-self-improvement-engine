{
  "cycle": null,
  "goal_id": "auto_goal_2",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/cli.py\nimport argparse\nfrom pathlib import Path\nimport os\nimport sys\nimport yaml\nimport logging # New import\nimport json # New import for JSON formatter\nfrom datetime import datetime # New import for JSON formatter\nfrom pydantic import ValidationError # Import ValidationError\n\nfrom .config import MainConfig, LoggingConfig\nfrom .core.engine import Engine\n\n# Set up a logger for the CLI module\nlogger = logging.getLogger(__name__)\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"A custom logging formatter that outputs logs in JSON format.\"\"\"\n    def format(self, record):\n        log_record = {\n            \"timestamp\": datetime.fromtimestamp(record.created).isoformat(),\n            \"level\": record.levelname,\n            \"name\": record.name,\n            \"message\": record.getMessage(),\n        }\n        if record.exc_info:\n            log_record[\"exc_info\"] = self.formatException(record.exc_info)\n        if record.stack_info:\n            log_record[\"stack_info\"] = self.formatStack(record.stack_info)\n\n        return json.dumps(log_record)\n\ndef _setup_logging(log_config: LoggingConfig):\n    \"\"\"Configures the root logger based on the provided logging configuration.\"\"\"\n    level_map = {level: getattr(logging, level.upper()) for level in [\"debug\", \"info\", \"warning\", \"error\", \"critical\"]}\n    log_level = level_map.get(log_config.level.lower(), logging.INFO)\n\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n    for handler in root_logger.handlers[:]: # Clear existing handlers\n        root_logger.removeHandler(handler)\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stderr)\n    console_handler.setLevel(log_level)\n\n    if log_config.format == \"json\":\n        formatter = JsonFormatter()\n    else:\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(message)s')\n\n    console_handler.setFormatter(formatter)\n    root_logger.addHandler(console_handler)\n\n    # File handler (if log_file is specified)\n    if log_config.log_file:\n        log_file_path = Path(log_config.log_file)\n        log_file_path.parent.mkdir(parents=True, exist_ok=True) # Ensure log directory exists\n        file_handler = logging.FileHandler(log_file_path, encoding='utf-8')\n        file_handler.setLevel(log_level)\n        file_handler.setFormatter(formatter)\n        root_logger.addHandler(file_handler)\n\n    logger.info(\"Logging configured to level '%s' with format '%s'. Outputting to console and %s.\", \n                log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n    parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n                        help=\"Path to the engine configuration file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", \n                        help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n    args = parser.parse_args()\n\n    # Load and validate configuration\n    config: MainConfig\n    try:\n        config_path = Path(args.config)\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n        \n        with open(config_path, 'r', encoding='utf-8') as f:\n            config_data = yaml.safe_load(f)\n        \n        config = MainConfig(**config_data) # Use MainConfig for validation\n\n        # Override log level if --verbose flag is set\n        if args.verbose:\n            config.logging.level = \"DEBUG\"\n\n        # Configure logging as early as possible after config is loaded\n        _setup_logging(config.logging)\n\n    except FileNotFoundError as e:\n        logger.error(\"Error: Config file not found at %s. %s\", config_path.absolute(), e, exc_info=False)\n        sys.exit(1)\n    except ValidationError as e:\n        logger.error(\"Configuration validation error: %s\", e, exc_info=True)\n        sys.exit(1)\n    except Exception as e:\n        logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n        sys.exit(1)\n\n    engine = Engine(config)\n    engine.run_cycles()\n\n# AI-generated improvements:\nimport subprocess # New import for running external commands\ndef _run_tests_with_coverage(test_target: str, config_file_path: Path) -> int:\n    \"\"\"\n    Runs pytest with coverage and generates reports.\n    Args:\n        test_target: The path to run tests on (e.g., '.', 'tests/').\n        config_file_path: The path to the main configuration file, used to determine\n                          the base directory for placing reports (e.g., 'config/engine_config.yaml').\n    Returns:\n        The exit code of the pytest process.\n    \"\"\"\n    try:\n        # Determine the base directory for reports (project root, assuming config is in <project_root>/config/)\n        project_root_for_reports = config_file_path.parent.parent\n        report_dir = project_root_for_reports / \"reports\"\n        report_dir.mkdir(parents=True, exist_ok=True)\n        coverage_xml_path = report_dir / \"coverage.xml\"\n        coverage_html_dir = report_dir / \"htmlcov\"\n        # The project source directory to measure coverage for is src/ai_self_ext_engine/\n        coverage_measure_path = Path(__file__).parent.as_posix()\n        cmd = [\n            sys.executable, \"-m\", \"pytest\",\n            test_target,\n            f\"--cov={coverage_measure_path}\",\n            \"--cov-report=term-missing\",\n            f\"--cov-report=xml:{coverage_xml_path}\",\n            f\"--cov-report=html:{coverage_html_dir}\",\n            \"--durations=0\",\n        ]\n        logger.info(\"Running tests with coverage: %s\", \" \".join(cmd))\n        process = subprocess.run(cmd, capture_output=True, text=True, check=False)\n        if process.stdout: logger.info(\"Pytest Output:\\n%s\", process.stdout)\n        if process.stderr: logger.error(\"Pytest Errors:\\n%s\", process.stderr)\n        logger.info(\"Coverage XML report generated at: %s\", coverage_xml_path.absolute())\n        logger.info(\"Coverage HTML report generated at: %s\", coverage_html_dir.absolute())\n        return process.returncode\n    except FileNotFoundError:\n        logger.error(\"Error: 'pytest' or 'python' command not found. Please ensure pytest and pytest-cov are installed (`pip install pytest pytest-cov`).\")\n        return 1\n    except Exception as e:\n        logger.exception(\"An unexpected error occurred during test execution: %s\", e)\n        return 1\n    parser.add_argument(\"--test\", nargs=\"?\", const=\".\", default=None,\n                        help=\"Run tests with coverage. Optionally specify a path or '.' for all tests. \"\n                             \"Generates XML and HTML coverage reports in a 'reports/' directory at the project root.\")\n    # Handle --test argument, if present\n    if args.test is not None:\n        logger.info(f\"Test mode activated. Running tests in '{args.test}' with coverage.\")\n        exit_code = _run_tests_with_coverage(args.test, config_path)\n        sys.exit(exit_code)\n\n# AI-generated improvements:\nimport typer\nfrom typing import Optional\nfrom src.ai_self_ext_engine.test_utils import run_tests_with_coverage\napp = typer.Typer()\nlogger = logging.getLogger(__name__)\n@app.command(name=\"test\", help=\"Run unit tests and generate a comprehensive code coverage report.\")\ndef run_tests_command(\n    tests_path: Optional[Path] = typer.Argument(\n        None,\n        help=\"Path to tests (file or directory). Defaults to 'tests' directory if exists.\",\n        exists=True,\n        file_okay=True,\n        dir_okay=True,\n        readable=True,\n    ),\n    coverage_report_dir: Path = typer.Option(\n        Path(\"coverage_reports\"),\n        \"--coverage-report-dir\",\n        \"-crd\",\n        help=\"Directory to save the code coverage XML report.\",\n        writable=True,\n    ),\n    project_root: Path = typer.Option(\n        Path(\".\"),\n        \"--project-root\",\n        \"-pr\",\n        help=\"The root directory of the project for coverage measurement.\",\n        exists=True,\n        dir_okay=True,\n        readable=True,\n    ),\n):\n    \"\"\"\n    Runs unit tests and generates a comprehensive code coverage report.\n    \"\"\"\n    if tests_path is None:\n        # Prioritize 'tests' in project root, then 'src/ai_self_ext_engine/tests', then 'src/tests'\n        if (project_root / \"tests\").is_dir():\n            tests_path = project_root / \"tests\"\n        elif (project_root / \"src\" / \"ai_self_ext_engine\" / \"tests\").is_dir():\n             tests_path = project_root / \"src\" / \"ai_self_ext_engine\" / \"tests\"\n        elif (project_root / \"src\" / \"tests\").is_dir():\n             tests_path = project_root / \"src\" / \"tests\"\n        else:\n            logger.error(\"No specific tests path provided and no 'tests' directory found in common locations. Please specify with 'ai-self-ext-engine test PATH_TO_TESTS'\")\n            raise typer.Exit(code=1)\n    logger.info(f\"Running tests from: {tests_path.resolve()}\")\n    logger.info(f\"Generating coverage report in: {coverage_report_dir.resolve()}\")\n    coverage_report_dir.mkdir(parents=True, exist_ok=True)\n    results = run_tests_with_coverage(project_root=project_root, test_path=tests_path, coverage_report_dir=coverage_report_dir)\n    if results['success']:\n        logger.info(f\"\\nTests completed successfully.\")\n        if results.get('coverage_xml_path'):\n            logger.info(f\"Code coverage report generated at: {results['coverage_xml_path'].resolve()}\")\n            if results.get('coverage_data'):\n                logger.info(f\"Coverage Summary:\")\n                for metric, value in results['coverage_data'].items():\n                    logger.info(f\"  {metric.replace('_', ' ').title()}: {value}\")\n        raise typer.Exit(code=0)\n    else:\n        logger.error(f\"\\nTests failed!\")\n        logger.error(f\"Stdout:\\n{results['stdout']}\")\n        logger.error(f\"Stderr:\\n{results['stderr']}\")\n        raise typer.Exit(code=1)\n\nif __name__ == \"__main__\":\n    main()\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/cli.py",
      "change_type": "modify",
      "description": "Add a new CLI command to execute tests and generate a code coverage report."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/cli.py\n+++ b/src/ai_self_ext_engine/cli.py\n@@ -5,12 +5,17 @@\n import os\n import sys\n import yaml\n import logging # New import\n import json # New import for JSON formatter\n from datetime import datetime # New import for JSON formatter\n+import typer # Added for CLI framework\n+from typing import Optional # Added for typer\n+from src.ai_self_ext_engine.test_utils import run_tests_with_coverage # Added for test command\n from pydantic import ValidationError # Import ValidationError\n \n from .config import MainConfig, LoggingConfig\n from .core.engine import Engine\n \n # Set up a logger for the CLI module\n logger = logging.getLogger(__name__)\n+\n+app = typer.Typer() # Initialize Typer application\n \n class JsonFormatter(logging.Formatter):\n     \"\"\"A custom logging formatter that outputs logs in JSON format.\"\"\"\n@@ -58,16 +63,26 @@\n                 log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n \n def main():\n-    parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n-    parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n-                        help=\"Path to the engine configuration file.\")\n-    parser.add_argument(\"--verbose\", action=\"store_true\", \n-                        help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n-    args = parser.parse_args()\n+@app.command(name=\"run\", help=\"Run the AI Self-Extending Engine with specified configuration.\")\n+def run_engine_command(\n+    config_path: Path = typer.Option(\n+        Path(\"config/engine_config.yaml\"),\n+        \"--config\",\n+        \"-c\",\n+        help=\"Path to the engine configuration file.\",\n+        exists=True, # Ensure file exists\n+        file_okay=True,\n+        dir_okay=False,\n+        readable=True,\n+    ),\n+    verbose: bool = typer.Option(\n+        False,\n+        \"--verbose\",\n+        \"-v\",\n+        help=\"Enable verbose logging (DEBUG level). Overrides config.\",\n+    )\n+):\n+    \"\"\"Runs the AI Self-Extending Engine.\"\"\"\n \n     # Load and validate configuration\n     config: MainConfig\n     try:\n-        config_path = Path(args.config)\n+        # config_path is already a Path object from typer.Option\n         if not config_path.exists():\n             raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n         \n         with open(config_path, 'r', encoding='utf-8') as f:\n             config_data = yaml.safe_load(f)\n         \n         config = MainConfig(**config_data) # Use MainConfig for validation\n \n         # Override log level if --verbose flag is set\n-        if args.verbose:\n+        if verbose:\n             config.logging.level = \"DEBUG\"\n \n         # Configure logging as early as possible after config is loaded\n@@ -92,57 +107,46 @@\n         logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n         sys.exit(1)\n \n     engine = Engine(config)\n     engine.run_cycles()\n \n-# AI-generated improvements:\n-import subprocess # New import for running external commands\n-def _run_tests_with_coverage(test_target: str, config_file_path: Path) -> int:\n-    \"\"\"\n-    Runs pytest with coverage and generates reports.\n-    Args:\n-        test_target: The path to run tests on (e.g., '.', 'tests/').\n-        config_file_path: The path to the main configuration file, used to determine\n-                          the base directory for placing reports (e.g., 'config/engine_config.yaml').\n-    Returns:\n-        The exit code of the pytest process.\n-    \"\"\"\n-    try:\n-        # Determine the base directory for reports (project root, assuming config is in <project_root>/config/)\n-        project_root_for_reports = config_file_path.parent.parent\n-        report_dir = project_root_for_reports / \"reports\"\n-        report_dir.mkdir(parents=True, exist_ok=True)\n-        coverage_xml_path = report_dir / \"coverage.xml\"\n-        coverage_html_dir = report_dir / \"htmlcov\"\n-        # The project source directory to measure coverage for is src/ai_self_ext_engine/\n-        coverage_measure_path = Path(__file__).parent.as_posix()\n-        cmd = [\n-            sys.executable, \"-m\", \"pytest\",\n-            test_target,\n-            f\"--cov={coverage_measure_path}\",\n-            \"--cov-report=term-missing\",\n-            f\"--cov-report=xml:{coverage_xml_path}\",\n-            f\"--cov-report=html:{coverage_html_dir}\",\n-            \"--durations=0\",\n-        ]\n-        logger.info(\"Running tests with coverage: %s\", \" \".join(cmd))\n-        process = subprocess.run(cmd, capture_output=True, text=True, check=False)\n-        if process.stdout: logger.info(\"Pytest Output:\\n%s\", process.stdout)\n-        if process.stderr: logger.error(\"Pytest Errors:\\n%s\", process.stderr)\n-        logger.info(\"Coverage XML report generated at: %s\", coverage_xml_path.absolute())\n-        logger.info(\"Coverage HTML report generated at: %s\", coverage_html_dir.absolute())\n-        return process.returncode\n-    except FileNotFoundError:\n-        logger.error(\"Error: 'pytest' or 'python' command not found. Please ensure pytest and pytest-cov are installed (`pip install pytest pytest-cov`).\")\n-        return 1\n-    except Exception as e:\n-        logger.exception(\"An unexpected error occurred during test execution: %s\", e)\n-        return 1\n-    parser.add_argument(\"--test\", nargs=\"?\", const=\".\", default=None,\n-                        help=\"Run tests with coverage. Optionally specify a path or '.' for all tests. \"\n-                             \"Generates XML and HTML coverage reports in a 'reports/' directory at the project root.\")\n-    # Handle --test argument, if present\n-    if args.test is not None:\n-        logger.info(f\"Test mode activated. Running tests in '{args.test}' with coverage.\")\n-        exit_code = _run_tests_with_coverage(args.test, config_path)\n-        sys.exit(exit_code)\n-\n-# AI-generated improvements:\n-import typer\n-from typing import Optional\n-from src.ai_self_ext_engine.test_utils import run_tests_with_coverage\n-app = typer.Typer()\n-logger = logging.getLogger(__name__)\n @app.command(name=\"test\", help=\"Run unit tests and generate a comprehensive code coverage report.\")\n def run_tests_command(\n     tests_path: Optional[Path] = typer.Argument(\n         None,\n         help=\"Path to tests (file or directory). Defaults to 'tests' directory if exists.\",\n         exists=True,\n         file_okay=True,\n         dir_okay=True,\n         readable=True,\n     ),\n     coverage_report_dir: Path = typer.Option(\n         Path(\"coverage_reports\"),\n         \"--coverage-report-dir\",\n         \"-crd\",\n         help=\"Directory to save the code coverage XML report.\",\n         writable=True,\n     ),\n     project_root: Path = typer.Option(\n         Path(\".\"),\n         \"--project-root\",\n         \"-pr\",\n         help=\"The root directory of the project for coverage measurement.\",\n         exists=True,\n         dir_okay=True,\n         readable=True,\n     ),\n ):\n     \"\"\"\n     Runs unit tests and generates a comprehensive code coverage report.\n     \"\"\"\n     if tests_path is None:\n         # Prioritize 'tests' in project root, then 'src/ai_self_ext_engine/tests', then 'src/tests'\n         if (project_root / \"tests\").is_dir():\n             tests_path = project_root / \"tests\"\n         elif (project_root / \"src\" / \"ai_self_ext_engine\" / \"tests\").is_dir():\n              tests_path = project_root / \"src\" / \"ai_self_ext_engine\" / \"tests\"\n         elif (project_root / \"src\" / \"tests\").is_dir():\n              tests_path = project_root / \"src\" / \"tests\"\n         else:\n             logger.error(\"No specific tests path provided and no 'tests' directory found in common locations. Please specify with 'ai-self-ext-engine test PATH_TO_TESTS'\")\n             raise typer.Exit(code=1)\n     logger.info(f\"Running tests from: {tests_path.resolve()}\")\n     logger.info(f\"Generating coverage report in: {coverage_report_dir.resolve()}\")\n     coverage_report_dir.mkdir(parents=True, exist_ok=True)\n     results = run_tests_with_coverage(project_root=project_root, test_path=tests_path, coverage_report_dir=coverage_report_dir)\n     if results['success']:\n         logger.info(f\"\\nTests completed successfully.\")\n         if results.get('coverage_xml_path'):\n             logger.info(f\"Code coverage report generated at: {results['coverage_xml_path'].resolve()}\")\n             if results.get('coverage_data'):\n                 logger.info(f\"Coverage Summary:\")\n                 for metric, value in results['coverage_data'].items():\n                     logger.info(f\"  {metric.replace('_', ' ').title()}: {value}\")\n         raise typer.Exit(code=0)\n     else:\n         logger.error(f\"\\nTests failed!\")\n         logger.error(f\"Stdout:\\n{results['stdout']}\")\n         logger.error(f\"Stderr:\\n{results['stderr']}\")\n         raise typer.Exit(code=1)\n \n if __name__ == \"__main__\":\n-    main()\n+    app()",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}