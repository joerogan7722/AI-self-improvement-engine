{
  "cycle": null,
  "goal_id": "auto_goal_2",
  "description": "Improve testing: Test coverage analysis and improvement needed",
  "current_code": "# File: src/ai_self_ext_engine/cli.py\nimport argparse\nfrom pathlib import Path\nimport os\nimport sys\nimport yaml\nimport logging # New import\nimport json # New import for JSON formatter\nfrom datetime import datetime # New import for JSON formatter\nfrom pydantic import ValidationError # Import ValidationError\n\nfrom .config import MainConfig, LoggingConfig\nfrom .core.engine import Engine\n\n# Set up a logger for the CLI module\nlogger = logging.getLogger(__name__)\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"A custom logging formatter that outputs logs in JSON format.\"\"\"\n    def format(self, record):\n        log_record = {\n            \"timestamp\": datetime.fromtimestamp(record.created).isoformat(),\n            \"level\": record.levelname,\n            \"name\": record.name,\n            \"message\": record.getMessage(),\n        }\n        if record.exc_info:\n            log_record[\"exc_info\"] = self.formatException(record.exc_info)\n        if record.stack_info:\n            log_record[\"stack_info\"] = self.formatStack(record.stack_info)\n\n        return json.dumps(log_record)\n\ndef _setup_logging(log_config: LoggingConfig):\n    \"\"\"Configures the root logger based on the provided logging configuration.\"\"\"\n    level_map = {level: getattr(logging, level.upper()) for level in [\"debug\", \"info\", \"warning\", \"error\", \"critical\"]}\n    log_level = level_map.get(log_config.level.lower(), logging.INFO)\n\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n    for handler in root_logger.handlers[:]: # Clear existing handlers\n        root_logger.removeHandler(handler)\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stderr)\n    console_handler.setLevel(log_level)\n\n    if log_config.format == \"json\":\n        formatter = JsonFormatter()\n    else:\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(name)s - %(message)s')\n\n    console_handler.setFormatter(formatter)\n    root_logger.addHandler(console_handler)\n\n    # File handler (if log_file is specified)\n    if log_config.log_file:\n        log_file_path = Path(log_config.log_file)\n        log_file_path.parent.mkdir(parents=True, exist_ok=True) # Ensure log directory exists\n        file_handler = logging.FileHandler(log_file_path, encoding='utf-8')\n        file_handler.setLevel(log_level)\n        file_handler.setFormatter(formatter)\n        root_logger.addHandler(file_handler)\n\n    logger.info(\"Logging configured to level '%s' with format '%s'. Outputting to console and %s.\", \n                log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n    parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n                        help=\"Path to the engine configuration file.\")\n    parser.add_argument(\"--verbose\", action=\"store_true\", \n                        help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n    args = parser.parse_args()\n\n    # Load and validate configuration\n    config: MainConfig\n    try:\n        config_path = Path(args.config)\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n        \n        with open(config_path, 'r', encoding='utf-8') as f:\n            config_data = yaml.safe_load(f)\n        \n        config = MainConfig(**config_data) # Use MainConfig for validation\n\n        # Override log level if --verbose flag is set\n        if args.verbose:\n            config.logging.level = \"DEBUG\"\n\n        # Configure logging as early as possible after config is loaded\n        _setup_logging(config.logging)\n\n    except FileNotFoundError as e:\n        logger.error(\"Error: Config file not found at %s. %s\", config_path.absolute(), e, exc_info=False)\n        sys.exit(1)\n    except ValidationError as e:\n        logger.error(\"Configuration validation error: %s\", e, exc_info=True)\n        sys.exit(1)\n    except Exception as e:\n        logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n        sys.exit(1)\n\n    engine = Engine(config)\n    engine.run_cycles()\n\nif __name__ == \"__main__\":\n    main()\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/cli.py",
      "change_type": "modify",
      "description": "Add a CLI command to run all tests and report code coverage."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/cli.py\n+++ b/src/ai_self_ext_engine/cli.py\n@@ -10,6 +10,7 @@\n \n from .config import MainConfig, LoggingConfig\n from .core.engine import Engine\n+from .test_utils import run_pytest_tests # New import for test command\n \n # Set up a logger for the CLI module\n logger = logging.getLogger(__name__)\n@@ -62,13 +63,80 @@\n     logger.info(\"Logging configured to level '%s' with format '%s'. Outputting to console and %s.\", \n                 log_config.level, log_config.format, log_config.log_file if log_config.log_file else \"console only\")\n \n+# Existing engine run logic, moved into a function for CLI subcommands\n+def _run_engine_command(args, config: MainConfig):\n+    \"\"\"Handles the 'engine' CLI command (default behavior).\"\"\"\n+    engine = Engine(config)\n+    engine.run_cycles()\n+\n+# New function for the 'test' command\n+def _run_tests_command(args, config: MainConfig):\n+    \"\"\"Handles the 'test' CLI command.\"\"\"\n+    logger.info(\"Starting test execution...\")\n+\n+    # Determine project root: Assuming cli.py is src/ai_self_ext_engine/cli.py, \n+    # then project root is 3 levels up from cli.py's path\n+    # (cli.py -> ai_self_ext_engine -> src -> project_root)\n+    project_root = Path(__file__).resolve().parent.parent.parent\n+\n+    # Resolve test_path relative to project_root\n+    # If args.test_path is '.', it correctly resolves to project_root itself.\n+    test_path = (project_root / args.test_path).resolve()\n+    \n+    if not test_path.exists():\n+        logger.error(f\"Error: Test path not found: {test_path}\")\n+        sys.exit(1)\n+\n+    # Ensure coverage reports directory exists within project_root\n+    coverage_report_dir = project_root / \".coverage_reports\"\n+    coverage_report_dir.mkdir(parents=True, exist_ok=True)\n+\n+    results = run_pytest_tests(\n+        project_root=project_root,\n+        test_path=test_path,\n+        coverage_report_dir=coverage_report_dir\n+    )\n+\n+    if results['success']:\n+        logger.info(\"All tests passed successfully.\")\n+    else:\n+        logger.error(\"Tests failed.\")\n+    \n+    logger.info(\"\\n--- Pytest Output ---\")\n+    if results['stdout']:\n+        print(results['stdout'])\n+    if results['stderr']:\n+        print(results['stderr'], file=sys.stderr)\n+    logger.info(\"--- End Pytest Output ---\\n\")\n+\n+    if results['coverage_data']:\n+        coverage = results['coverage_data']['overall']\n+        logger.info(\"--- Code Coverage Summary ---\")\n+        logger.info(f\"Overall Line Rate: {coverage['line_rate'] * 100:.2f}%\")\n+        logger.info(f\"Lines Covered: {coverage['lines_covered']}\")\n+        logger.info(f\"Lines Valid: {coverage['lines_valid']}\")\n+        \n+        if results['coverage_xml_path'] and results['coverage_xml_path'].exists():\n+            logger.info(f\"Full coverage report saved to: {results['coverage_xml_path']}\")\n+        \n+        logger.debug(\"Per-file Coverage:\")\n+        for file_data in results['coverage_data']['files']:\n+            # Normalize filename path to be relative to project_root if possible\n+            display_filename = file_data['filename']\n+            try:\n+                abs_filename_path = Path(display_filename)\n+                if abs_filename_path.is_absolute():\n+                    relative_filename = abs_filename_path.relative_to(project_root)\n+                    display_filename = str(relative_filename)\n+            except ValueError:\n+                pass # Keep original path if not relative to project_root\n+            logger.debug(f\"  {display_filename}: {file_data['line_rate'] * 100:.2f}%\")\n+        logger.info(\"--- End Code Coverage Summary ---\")\n+    else:\n+        logger.info(\"Code coverage not reported (pytest-cov might not be installed or no coverage data generated).\")\n+\n+    if not results['success']:\n+        sys.exit(1)\n+\n def main():\n     parser = argparse.ArgumentParser(description=\"AI Self-Extending Engine\")\n     parser.add_argument(\"--config\", type=str, default=\"config/engine_config.yaml\",\n                         help=\"Path to the engine configuration file.\")\n     parser.add_argument(\"--verbose\", action=\"store_true\", \n                         help=\"Enable verbose logging (DEBUG level). Overrides config.\")\n \n+    # Create subparsers for different commands\n+    subparsers = parser.add_subparsers(dest=\"command\", help=\"Available commands\")\n+\n+    # Command for running the engine\n+    engine_parser = subparsers.add_parser(\"engine\", help=\"Run the AI Self-Extending Engine.\")\n+    engine_parser.set_defaults(func=_run_engine_command)\n+\n+    # Command for running tests\n+    test_parser = subparsers.add_parser(\"test\", help=\"Run all tests and report code coverage.\")\n+    test_parser.add_argument(\"test_path\", type=str, nargs=\"?\", default=\".\", \n+                             help=\"Path to tests to run (e.g., 'tests/unit' or '.'). Defaults to project root.\")\n+    test_parser.set_defaults(func=_run_tests_command)\n+\n     args = parser.parse_args()\n \n     # Load and validate configuration\n     try:\n         config_path = Path(args.config)\n         if not config_path.exists():\n             raise FileNotFoundError(f\"Config file not found at {config_path.absolute()}\")\n         \n         with open(config_path, 'r', encoding='utf-8') as f:\n             config_data = yaml.safe_load(f)\n         \n@@ -95,9 +163,10 @@\n         logger.error(\"Error loading or parsing configuration: %s\", e, exc_info=True)\n         sys.exit(1)\n \n-    engine = Engine(config)\n-    engine.run_cycles()\n+    # Execute the chosen command or default to engine\n+    if args.command: # A specific command was chosen\n+        args.func(args, config)\n+    else: # No command specified, run the engine by default\n+        logger.info(\"No command specified. Running the AI Self-Extending Engine by default.\")\n+        _run_engine_command(args, config)\n \n if __name__ == \"__main__\":\n     main()",
  "test_results": null,
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}