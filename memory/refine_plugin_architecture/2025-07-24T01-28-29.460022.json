{
  "cycle": null,
  "goal_id": "refine_plugin_architecture",
  "description": "Refine the plugin architecture to make it more extensible and easier to add new capabilities.",
  "current_code": "# File: src/ai_self_ext_engine/core/plugin_manager.py\nimport importlib.util\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Type, Any, List, Optional\n\nlogger = logging.getLogger(__name__)\n\n# Define a simple base class for plugins\nclass BasePlugin:\n    \"\"\"\n    Base class for all plugins managed by the PluginManager.\n    Plugins should inherit from this class and implement the required methods.\n    \"\"\"\n    name: str = \"UnnamedPlugin\"\n    description: str = \"A generic plugin.\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initializes the base plugin. Concrete plugins can extend this to accept\n        configuration or dependencies.\n        \"\"\"\n        pass\n\n    async def execute(self, context: Any) -> Any:\n        \"\"\"\n        Execute the plugin's primary action.\n        This method must be implemented by concrete plugin classes.\n        It is designed to be async to facilitate future parallel execution.\n\n        Args:\n            context: The current execution context, which can be modified by the plugin.\n\n        Returns:\n            The updated execution context.\n        \"\"\"\n        raise NotImplementedError(\"Plugin must implement the 'execute' method.\")\n\n    def __repr__(self):\n        return f\"<Plugin: {self.name}>\"\n\nclass PluginManager:\n    \"\"\"\n    Manages the loading, registration, and access to various plugins.\n    Lays the groundwork for improved plugin architecture and facilitates future\n    parallel execution of plugin actions by managing plugins that conform to\n    an async interface (`BasePlugin`).\n    \"\"\"\n    def __init__(self):\n        self._plugins: Dict[str, BasePlugin] = {}\n        logger.debug(\"PluginManager initialized.\")\n\n    def register_plugin(self, plugin_instance: BasePlugin):\n        \"\"\"\n        Registers a plugin instance with the manager.\n\n        Args:\n            plugin_instance: An instance of a class inheriting from BasePlugin.\n        \"\"\"\n        if not isinstance(plugin_instance, BasePlugin):\n            raise TypeError(f\"Provided object is not an instance of BasePlugin: {type(plugin_instance)}\")\n\n        if plugin_instance.name in self._plugins:\n            logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n\n        self._plugins[plugin_instance.name] = plugin_instance\n        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n\n    def get_plugin(self, name: str) -> Optional[BasePlugin]:\n        \"\"\"\n        Retrieves a registered plugin by its name.\n\n        Args:\n            name: The name of the plugin to retrieve.\n\n        Returns:\n            The BasePlugin instance if found, otherwise None.\n        \"\"\"\n        return self._plugins.get(name)\n\n    def get_all_plugins(self) -> Dict[str, BasePlugin]:\n        \"\"\"\n        Retrieves a copy of all registered plugins, keyed by their names.\n        \"\"\"\n        return self._plugins.copy()\n\n    def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n        \"\"\"\n        Scans a directory for Python files, attempts to import them as modules,\n        and registers classes inheriting from `plugin_base_class` as plugins.\n        \"\"\"\n        if not plugin_dir.is_dir():\n            logger.warning(f\"Plugin directory not found or is not a directory: {plugin_dir}\")\n            return\n\n        logger.info(f\"Loading plugins from directory: {plugin_dir}\")\n        for filepath in plugin_dir.glob(\"*.py\"):\n            if filepath.name == \"__init__.py\":\n\n\n",
  "todos": [
    {
      "file_path": "src/ai_self_ext_engine/core/plugin_manager.py",
      "change_type": "modify",
      "description": "Enhance PluginManager to provide a mechanism for loaded plugins to register and expose their specific capabilities (e.g., custom tools, data handlers) for discovery and utilization by other engine components."
    }
  ],
  "patch": "--- a/src/ai_self_ext_engine/core/plugin_manager.py\n+++ b/src/ai_self_ext_engine/core/plugin_manager.py\n@@ -14,6 +14,8 @@\n     \"\"\"\n     name: str = \"UnnamedPlugin\"\n     description: str = \"A generic plugin.\"\n+    # A dictionary to expose specific capabilities (e.g., tools, data handlers)\n+    capabilities: Dict[str, Any] = {}\n \n     def __init__(self, **kwargs):\n         \"\"\"\n@@ -41,6 +43,8 @@\n     \"\"\"\n     def __init__(self):\n         self._plugins: Dict[str, BasePlugin] = {}\n+        # Store capabilities exposed by registered plugins\n+        self._all_plugin_capabilities: Dict[str, Dict[str, Any]] = {}\n         logger.debug(\"PluginManager initialized.\")\n \n     def register_plugin(self, plugin_instance: BasePlugin):\n@@ -54,7 +58,11 @@\n         if plugin_instance.name in self._plugins:\n             logger.warning(f\"Plugin '{plugin_instance.name}' already registered. Overwriting existing plugin.\")\n \n         self._plugins[plugin_instance.name] = plugin_instance\n-        logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n+        # Store the plugin's capabilities\n+        if plugin_instance.capabilities:\n+            self._all_plugin_capabilities[plugin_instance.name] = plugin_instance.capabilities\n+            logger.info(f\"Plugin '{plugin_instance.name}' registered with capabilities: {list(plugin_instance.capabilities.keys())}\")\n+        else:\n+            logger.info(f\"Plugin '{plugin_instance.name}' registered.\")\n \n     def get_plugin(self, name: str) -> Optional[BasePlugin]:\n         \"\"\"\n@@ -75,6 +83,30 @@\n         \"\"\"\n         return self._plugins.copy()\n \n+    def get_plugin_capabilities(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n+        \"\"\"\n+        Retrieves the capabilities exposed by a specific registered plugin.\n+\n+        Args:\n+            plugin_name: The name of the plugin.\n+\n+        Returns:\n+            A dictionary of capabilities if the plugin is found and exposes any, otherwise None.\n+        \"\"\"\n+        return self._all_plugin_capabilities.get(plugin_name)\n+\n+    def get_all_plugin_capabilities(self) -> Dict[str, Dict[str, Any]]:\n+        \"\"\"\n+        Retrieves a copy of all capabilities registered by all plugins,\n+        keyed by plugin name.\n+\n+        Returns:\n+            A dictionary where keys are plugin names and values are their\n+            respective capabilities dictionaries.\n+        \"\"\"\n+        return self._all_plugin_capabilities.copy()\n+\n     def load_plugins_from_directory(self, plugin_dir: Path, plugin_base_class: Type[BasePlugin] = BasePlugin):\n         \"\"\"\n         Scans a directory for Python files, attempts to import them as modules,",
  "test_results": {
    "passed": false,
    "error": "pytest not found"
  },
  "accepted": false,
  "should_abort": true,
  "metadata": {}
}